@misc{AMDErrata:15hModels00h-0Fh-Rev-3-24,
    Author	= {Advanced Micro Devices Inc.},
    Title	= {Revision Guide for {AMD} Family 15h Models 00h-0Fh Processors},
    Number	= {48063},
    Month	= {September},
    Year	= {2014},
    URL		= {http://support.amd.com/TechDocs/48063\_15h\_Mod\_00h-0Fh\_Rev\_Guide.pdf},
    note	= {http://support.amd.com/TechDocs/48063\_15h\_Mod\_00h-0Fh\_Rev\_Guide.pdf}
}

@book{HopcroftMotwaniUllman:Automata01,
  Author = {Hopcroft, John E. and Motwani, Rajeev and Ullman, Jeffrey D.},
  Title  = {Introduction to Automata Theory, Languages, and Computation},
  Year   = {2001},
  Edition = {2$^{nd}$},
  ISBN   = {0-201-44124-1},
  Publisher = {Addison-Wesley},
  City   = {Boston, MA}
}

@inproceedings{ACE:MICRO07,
  author =       {Constantinides, Kypros and Mutlu, Onur and Austin, Todd and
                  Bertacco, Valeria},
  title =        {Software-Based Online Detection of Hardware Defects Mechanisms,
                  Architectural Support, and Evaluation},
  booktitle =    {Proceedings of the 40th Annual IEEE/ACM International Symposium on
                  Microarchitecture},
  series =       {MICRO 40},
  year =         {2007},
  isbn =         {0-7695-3047-8},
  pages =        {97--108},
  numpages =     {12},
  doi =          {10.1109/MICRO.2007.39},
  acmid =        {1331711},
  publisher =    {IEEE Computer Society},
  address =      {Washington, DC, USA},
}

@techreport{AMD_Bug_TechReport,
  title =        {Hardware Vulnerability and Mitigation Survey},
  author =       {Dharsee, Komail and Johnson, Ethan and Criswell, John},
  number =       {TR 1000},
  month =        {July},
  year =         {2017},
  url =          {http://hdl.handle.net/1802/32871},
  affiliation =  {Department of Computer Science, University of Rochester}
}

@misc{AMDErrata:10h-Rev-3-92,
  Author =       {Advanced Micro Devices Inc.},
  Title =        {Revision Guide for {AMD} Family 10h Processors},
  Number =       {41322},
  Month =        {March},
  Year =         {2012},
  URL =          {http://support.amd.com/TechDocs/41322\_10h\_Rev\_Gd.pdf},
  note =         {http://support.amd.com/TechDocs/41322\_10h\_Rev\_Gd.pdf}
}

@misc{AMDErrata:11h-Rev-3-10,
  Author =       {Advanced Micro Devices Inc.},
  Title =        {Revision Guide for {AMD} Family 11h Processors},
  Number =       {41788},
  Month =        {December},
  Year =         {2011},
  URL =          {http://support.amd.com/TechDocs/41788\_11h\_Rev\_Gd.pdf},
  note =         {http://support.amd.com/TechDocs/41788\_11h\_Rev\_Gd.pdf}
}

@article{AMDSVMRefManual,
  title =        {Secure virtual machine architecture reference manual},
  author =       {Advanced Micro Devices Inc.},
  journal =      {AMD Publication},
  number =       {33047},
  year =         {2005}
}

@article{CFI:TISSEC09,
  author =       {Abadi, Mart\'{\i}n and Budiu, Mihai and Erlingsson, \'{U}lfar and
                  Ligatti, Jay},
  title =        {Control-Flow Integrity Principles, Implementations, and
                  Applications},
  journal =      {ACM Transactions on Information Systems Security},
  issue_date =   {October 2009},
  volume =       {13},
  issue =        {1},
  month =        {November},
  year =         {2009},
  issn =         {1094-9224},
  pages =        {4:1--4:40},
  articleno =    {4},
  numpages =     {40},
  url =          {http://doi.acm.org/10.1145/1609956.1609960},
  doi =          {10.1145/1609956.1609960},
  acmid =        {1609960},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {Binary rewriting, control-flow graph, inlined reference monitors,
                  vulnerabilities},
}
@inproceedings{HardErrors:ASPLOS08,
  author =       {Li, Man-Lap and Ramachandran, Pradeep and Sahoo, Swarup Kumar and
                  Adve, Sarita V. and Adve, Vikram S. and Zhou, Yuanyuan},
  title =        {Understanding the Propagation of Hard Errors to Software and
                  Implications for Resilient System Design},
  booktitle =    {Proceedings of the 13th International Conference on Architectural
                  Support for Programming Languages and Operating Systems},
  series =       {ASPLOS XIII},
  year =         {2008},
  isbn =         {978-1-59593-958-6},
  location =     {Seattle, WA, USA},
  pages =        {265--276},
  numpages =     {12},
  doi =          {10.1145/1346281.1346315},
  acmid =        {1346315},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {architecture, error detection, fault injection, permanent fault},
}

@inproceedings{KCoFI:Oakland14,
  author =       {Criswell, John and Dautenhahn, Nathan and Adve, Vikram},
  title =        {{KCoFI: Complete Control-Flow Integrity for Commodity Operating
                  System Kernels}},
  booktitle =    {Proceedings of the 35th IEEE Symposium on Security and Privacy
                  (S\&P)},
  year =         {2014},
  month =        "May",
  isbn =         {978-1-4799-4686-0},
  address =      {San Jose, CA},
  pages =        {292--307},
  numpages =     {16},
  url =          {https://doi.org/10.1109/SP.2014.26},
  doi =          {10.1109/SP.2014.26},
  acmid =        {2650804},
  keywords =     {control-flow integrity, operating systems, Free BSD, compiler,
                  formal verification},
}

@inproceedings{LLVAOS:WIOSCA06,
  author =       "John Criswell and Brent Monroe and Vikram Adve",
  title =        "A Virtual Instruction Set Interface for Operating System Kernels",
  booktitle =    WIOSCA,
  year =         {2006},
  address =      {Boston, MA, USA},
  month =        {June},
  pages =        {26--33},
}

@inproceedings{LLVM:CGO04,
  author =       {Lattner, Chris and Adve, Vikram},
  title =        {{LLVM}: A Compilation Framework for Lifelong Program Analysis \&
                  Transformation},
  booktitle =    {Proceedings of the International Symposium on Code Generation and
                  Optimization: Feedback-directed and Runtime Optimization},
  series =       {CGO'04},
  year =         {2004},
  isbn =         {0-7695-2102-9},
  address =      {Palo Alto, CA},
  pages =        {75--86},
  numpages =     {12},
  url =          {http://dl.acm.org/citation.cfm?id=977395.977673},
  acmid =        {977673},
  publisher =    {IEEE Computer Society},
}

@inproceedings{lmbench,
  author =       {McVoy, Larry and Staelin, Carl},
  title =        {{lmbench: Portable Tools for Performance Analysis}},
  booktitle =    {Proceedings of the USENIX Annual Technical Conference (ATC)},
  year =         {1996},
  address =      {San Diego, CA},
  pages =        {23--23},
  numpages =     {1},
  url =          {http://dl.acm.org/citation.cfm?id=1268299.1268322},
  acmid =        {1268322},
}

@inproceedings{Meltdown:UsenixSec18,
  author =       {Lipp, Moritz and Schwarz, Michael and Gruss, Daniel and Prescher,
                  Thomas and Haas, Werner and Fogh, Anders and Horn, Jann and
                  Mangard, Stefan and Kocher, Paul and Genkin, Daniel and Yarom,
                  Yuval and Hamburg, Mike},
  title =        {Meltdown: Reading Kernel Memory from User Space},
  booktitle =    {Proceedings of the 27th USENIX Security Symposium},
  series =       {Security'18},
  year =         {2018},
  isbn =         {978-1-931971-46-1},
  address =      {Baltimore, MD},
  pages =        {973--990},
  numpages =     {18},
  url =
                  {https://www.usenix.org/conference/usenixsecurity18/presentation/lipp},
  acmid =        {3277276},
  publisher =    {USENIX Association},
}

@InProceedings{Phoenix:MICRO06,
  author =       {Smruti R. Sarangi, Abhishek Tiwari, Josep Torrellas},
  title =        {Phoenix: Detecting and Recovering from Permanent Processor Design
                  Bugs with Programmable Hardware},
  booktitle =    {Proceedings of 39th Annual IEEE/ACM International Symposium on
                  Microarchitecture, MICRO-39},
  pages =        {26--37},
  year =         {2006},
  month =        {Dec},
  city =         {Orlando, FL}
}

@misc{postmark,
  author =       "Postmark",
  title =        "Email delivery for web apps",
  year =         "2013",
  month =        "July",
  URL =          "https://postmarkapp.com/"
}

@inproceedings{RTLBugs:MICRO08,
  author =       {Constantinides, Kypros and Mutlu, Onur and Austin, Todd},
  title =        {Online Design Bug Detection: RTL Analysis, Flexible Mechanisms, and
                  Evaluation},
  booktitle =    {Proceedings of the 41st Annual IEEE/ACM International Symposium on
                  Microarchitecture},
  series =       {MICRO 41},
  year =         {2008},
  isbn =         {978-1-4244-2836-6},
  pages =        {282--293},
  numpages =     {12},
  doi =          {10.1109/MICRO.2008.4771798},
  acmid =        {1521801},
  publisher =    {IEEE Computer Society},
  address =      {Washington, DC, USA},
} 

@inproceedings{SFI:SOSP93,
  author =       {Wahbe, Robert and Lucco, Steven and Anderson, Thomas E. and Graham,
                  Susan L.},
  title =        {Efficient Software-Based Fault Isolation},
  booktitle =    {Proceedings of the 14th ACM Symposium on Operating Systems
                  Principles},
  series =       {SOSP'93},
  year =         {1993},
  isbn =         {0-89791-632-8},
  address =      {Asheville, NC},
  pages =        {203--216},
  numpages =     {14},
  url =          {http://doi.acm.org/10.1145/168619.168635},
  doi =          {10.1145/168619.168635},
  acmid =        {168635},
  publisher =    {ACM},
}

@inproceedings{SFS:CGO11,
  author =       {Hardekopf, Ben and Lin, Calvin},
  title =        {Flow-sensitive Pointer Analysis for Millions of Lines of Code},
  booktitle =    {Proceedings of the 9th Annual IEEE/ACM International Symposium on
                  Code Generation and Optimization},
  series =       {CGO '11},
  year =         {2011},
  isbn =         {978-1-61284-356-8},
  pages =        {289--298},
  numpages =     {10},
  url =          {http://dl.acm.org/citation.cfm?id=2190025.2190075},
  acmid =        {2190075},
  publisher =    {IEEE Computer Society},
  address =      {Washington, DC, USA},
}

@inproceedings{SPECS:ASPLOS15,
  author =       {Hicks, Matthew and Sturton, Cynthia and King, Samuel T. and Smith,
                  Jonathan M.},
  title =        {{SPECS}: A Lightweight Runtime Mechanism for Protecting Software
                  from Security-Critical Processor Bugs},
  booktitle =    {Proceedings of the Twentieth International Conference on
                  Architectural Support for Programming Languages and Operating
                  Systems},
  series =       {ASPLOS '15},
  year =         {2015},
  isbn =         {978-1-4503-2835-7},
  location =     {Istanbul, Turkey},
  pages =        {517--529},
  numpages =     {13},
  url =          {http://doi.acm.org/10.1145/2694344.2694366},
  doi =          {10.1145/2694344.2694366},
  acmid =        {2694366},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {hardware security exploits, processor errata, security-critical
                  processor errata},
}

@inproceedings{SVAOS:UsenixSec09,
  author =       {Criswell, John and Geoffray, Nicolas and Adve, Vikram},
  title =        {Memory Safety for Low-level Software/Hardware Interactions},
  booktitle =    {Proceedings of the 18th USENIX Security Symposium},
  series =       {Security'09},
  year =         {2009},
  location =     {Montreal, QC, Canada},
  pages =        {83--100},
  numpages =     {18},
  url =          {http://dl.acm.org/citation.cfm?id=1855768.1855774},
  acmid =        {1855774},
}

@inproceedings{SVA:SOSP07,
  author =       {Criswell, John and Lenharth, Andrew and Dhurjati, Dinakar and Adve,
                  Vikram},
  title =        {{Secure Virtual Architecture}: A Safe Execution Environment for
                  Commodity Operating Systems},
  booktitle =    {Proceedings of the 21st ACM SIGOPS Symposium on Operating Systems
                  Principles},
  series =       {SOSP'07},
  year =         {2007},
  isbn =         {978-1-59593-591-5},
  address =      {Stevenson, WA},
  pages =        {351--366},
  numpages =     {16},
  url =          {http://doi.acm.org/10.1145/1294261.1294295},
  doi =          {10.1145/1294261.1294295},
  acmid =        {1294295},
  publisher =    {ACM},
  keywords =     {compiler, memory safety, operating systems, security, type safety,
                  typed assembly language, virtual machine},
}

@article{SWAT:SELSE08,
  title =        {Swat: An error resilient system},
  author =       {Man-Lap Li and Pradeep Ramachandran and Swarup K Sahoo and Sarita
                  Adveand Vikram S Adveand Yuanyuan Zhou},
  journal =      {Proceedings of SELSE},
  year =         {2008}
}

@Article{TheSSAPaper,
  author =       "Ron Cytron and Jeanne Ferrante and Barry K. Rosen and Mark
                  N. Wegman and F. Kenneth Zadeck",
  title =        "Efficiently computing static single assignment form and the control
                  dependence graph",
  journal =      TOPLAS,
  pages =        "13(4):451-490",
  month =        "October",
  year =         1991
}


@inproceedings{VSA:CC08,
  author =       {Reps, Thomas and Balakrishnan, Gogul},
  title =        {Improved Memory-access Analysis for x86 Executables},
  booktitle =    {Proceedings of the Joint European Conferences on Theory and
                  Practice of Software 17th International Conference on Compiler
                  Construction},
  series =       {CC'08/ETAPS'08},
  year =         {2008},
  isbn =         {3-540-78790-9, 978-3-540-78790-7},
  location =     {Budapest, Hungary},
  pages =        {16--35},
  numpages =     {20},
  url =          {http://dl.acm.org/citation.cfm?id=1788374.1788377},
  acmid =        {1788377},
  publisher =    {Springer-Verlag},
  address =      {Berlin, Heidelberg},
}

@Article{optional:lastname:confyear,
  author =       "Solso, Robert L.  and King, Joseph F.",
  title =        "Frequency and versatility of letters in the English language",
  journal =      "Behavior Research Methods {\&} Instrumentation",
  year =         "1976",
  month =        "May",
  day =          "01",
  volume =       "8",
  number =       "3",
  pages =        "283--286",
  abstract =     "Tabulations of letter and letter-combination versatility and
                  frequency were made based on the Kucera and Francis (1967)
                  word frequency count. Letter versatility, a new descriptive
                  statistic, was defined as the number of different words in
                  which a letter appears. These tabulations may be useful in the
                  investigation of visual information processing, reading
                  skills, and human memory.",
  issn =         "1554-3528",
  doi =          "10.3758/BF03201714",
  url =          "https://doi.org/10.3758/BF03201714"
}


@inproceedings{zhang:asplos2017,
  author =       {Zhang, Rui and Stanley, Natalie and Griggs, Christopher and
                  Chi, Andrew and Sturton, Cynthia},
  title =        {Identifying Security Critical Properties for the Dynamic
                  Verification of a Processor},
  booktitle =    {Proceedings of the Twenty-Second International Conference on
                  Architectural Support for Programming Languages and Operating
                  Systems},
  series =       {ASPLOS '17},
  year =         {2017},
  isbn =         {978-1-4503-4465-4},
  location =     {Xi'an, China},
  pages =        {541--554},
  numpages =     {14},
  url =          {http://doi.acm.org/10.1145/3037697.3037734},
  doi =          {10.1145/3037697.3037734},
  acmid =        {3037734},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {hardware security, processor errata, security properties,
                  supervised learning},
}

@INPROCEEDINGS{bradfield:host2016,
  author =       {C. {Bradfield} and C. {Sturton}},
  booktitle =    {2016 IEEE International Symposium on Hardware Oriented
                  Security and Trust (HOST)},
  title =        {Model checking to find vulnerabilities in an instruction set
                  architecture},
  year =         {2016},
  volume =       {},
  number =       {},
  pages =        {109-113},
  abstract =     {Hardware companies conduct extensive testing and verification
                  during the processor design process to reduce the number of
                  errata that persist to the final product. These processes rely
                  on a specification against which to test or verify the design;
                  as a result, they will fail to catch vulnerabilities stemming
                  from errors in the specification itself. In this work we
                  present a model-checking based approach for detecting such
                  vulnerabilities. Our approach is feasible, even for a modern
                  CISC architecture, given the class of properties we are
                  interested in. We demonstrate the value of this approach with
                  a case study of the Intel SYSRET vulnerability.},
  keywords =     {formal verification;instruction sets;security of data;model
                  checking;instruction set architecture;processor design
                  process;vulnerabilities detection;CISC architecture;Intel
                  SYSRET
                  vulnerability;Software;Security;Registers;Hardware;Model
                  checking;Computer architecture;Companies},
  doi =          {10.1109/HST.2016.7495566},
  ISSN =         {},
  month =        {May},
}

@inproceedings{nelson:sosp2019,
  author =       {Nelson, Luke and Bornholt, James and Gu, Ronghui and Baumann,
                  Andrew and Torlak, Emina and Wang, Xi},
  title =        {Scaling Symbolic Evaluation for Automated Verification of
                  Systems Code with Serval},
  booktitle =    {Proceedings of the 27th ACM Symposium on Operating Systems
                  Principles},
  series =       {SOSP '19},
  year =         {2019},
  isbn =         {978-1-4503-6873-5},
  location =     {Huntsville, Ontario, Canada},
  pages =        {225--242},
  numpages =     {18},
  url =          {http://doi.acm.org/10.1145/3341301.3359641},
  doi =          {10.1145/3341301.3359641},
  acmid =        {3359641},
  publisher =    {ACM},
  address =      {New York, NY, USA},
} 

@article{Armstrong:2019:ISA,
  author =       {Armstrong, Alasdair and Bauereiss, Thomas and Campbell, Brian
                  and Reid, Alastair and Gray, Kathryn E. and Norton, Robert
                  M. and Mundkur, Prashanth and Wassell, Mark and French, Jon
                  and Pulte, Christopher and Flur, Shaked and Stark, Ian and
                  Krishnaswami, Neel and Sewell, Peter},
  title =        {ISA Semantics for ARMv8-a, RISC-v, and CHERI-MIPS},
  journal =      {Proc. ACM Program. Lang.},
  issue_date =   {January 2019},
  volume =       {3},
  number =       {POPL},
  month =        jan,
  year =         {2019},
  issn =         {2475-1421},
  pages =        {71:1--71:31},
  articleno =    {71},
  numpages =     {31},
  url =          {http://doi.acm.org/10.1145/3290384},
  doi =          {10.1145/3290384},
  acmid =        {3290384},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {Instruction Set Architectures, Semantics, Theorem Proving},
}
@article{sail:armstrong:2019:ISA,
  author =       {Armstrong, Alasdair and Bauereiss, Thomas and Campbell, Brian
                  and Reid, Alastair and Gray, Kathryn E. and Norton, Robert
                  M. and Mundkur, Prashanth and Wassell, Mark and French, Jon
                  and Pulte, Christopher and Flur, Shaked and Stark, Ian and
                  Krishnaswami, Neel and Sewell, Peter},
  title =        {ISA Semantics for ARMv8-a, RISC-v, and CHERI-MIPS},
  journal =      {Proc. ACM Program. Lang.},
  issue_date =   {January 2019},
  volume =       {3},
  number =       {POPL},
  month =        jan,
  year =         {2019},
  issn =         {2475-1421},
  pages =        {71:1--71:31},
  articleno =    {71},
  numpages =     {31},
  url =          {http://doi.acm.org/10.1145/3290384},
  doi =          {10.1145/3290384},
  acmid =        {3290384},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {Instruction Set Architectures, Semantics, Theorem Proving},
}

@inproceedings{Gray:2015:MICRO,
  author =       {Gray, Kathryn E. and Kerneis, Gabriel and Mulligan, Dominic
                  and Pulte, Christopher and Sarkar, Susmit and Sewell, Peter},
  title =        {An Integrated Concurrency and core-ISA Architectural Envelope
                  Definition, and Test Oracle, for IBM POWER Multiprocessors},
  booktitle =    {Proceedings of the 48th International Symposium on
                  Microarchitecture},
  series =       {MICRO-48},
  year =         {2015},
  isbn =         {978-1-4503-4034-2},
  location =     {Waikiki, Hawaii},
  pages =        {635--646},
  numpages =     {12},
  url =          {http://doi.acm.org/10.1145/2830772.2830775},
  doi =          {10.1145/2830772.2830775},
  acmid =        {2830775},
  publisher =    {ACM},
  address =      {New York, NY, USA},
}

@inproceedings{Flur:2016:POPL,
  author =       {Flur, Shaked and Gray, Kathryn E. and Pulte, Christopher and
                  Sarkar, Susmit and Sezgin, Ali and Maranget, Luc and Deacon,
                  Will and Sewell, Peter},
  title =        {Modelling the ARMv8 Architecture, Operationally: Concurrency
                  and ISA},
  booktitle =    {Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on
                  Principles of Programming Languages},
  series =       {POPL '16},
  year =         {2016},
  isbn =         {978-1-4503-3549-2},
  location =     {St. Petersburg, FL, USA},
  pages =        {608--621},
  numpages =     {14},
  url =          {http://doi.acm.org/10.1145/2837614.2837615},
  doi =          {10.1145/2837614.2837615},
  acmid =        {2837615},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {ISA, Relaxed Memory Models, semantics},
}

@article{kami:choi:pacmpl2017,
  author =       {Choi, Joonwon and Vijayaraghavan, Muralidaran and Sherman,
                  Benjamin and Chlipala, Adam and Arvind},
  title =        {Kami: A Platform for High-level Parametric Hardware
                  Specification and Its Modular Verification},
  journal =      {Proc. ACM Program. Lang.},
  issue_date =   {September 2017},
  volume =       {1},
  number =       {ICFP},
  month =        aug,
  year =         {2017},
  issn =         {2475-1421},
  pages =        {24:1--24:30},
  articleno =    {24},
  numpages =     {30},
  url =          {http://doi.acm.org/10.1145/3110268},
  doi =          {10.1145/3110268},
  acmid =        {3110268},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {formal verification, hardware, proof assistants},
}

@INPROCEEDINGS{uclid5:seshia:memocode2018,
  author =       {S. A. {Seshia} and P. {Subramanyan}},
  booktitle =    {2018 16th ACM/IEEE International Conference on Formal Methods
                  and Models for System Design (MEMOCODE)},
  title =        {UCLID5: Integrating Modeling, Verification, Synthesis and
                  Learning},
  year =         {2018},
  volume =       {},
  number =       {},
  pages =        {1-10},
  abstract =     {Formal methods for system design are facing a confluence of
                  transformative trends. First, systems are increasingly
                  heterogeneous, comprising some combination of hardware,
                  software, networking, and physical processes. Second, these
                  systems are increasingly being designed with data-driven
                  methods, in addition to traditional model-based design
                  techniques. Third, traditional automated reasoning techniques
                  based on deduction are being combined with new techniques for
                  inductive inference and machine learning. In this paper, we
                  present UCLID5, a new system for formal modeling,
                  verification, and synthesis that addresses the challenges and
                  opportunities arising from this confluence. UCLID5 can model
                  heterogeneous computational systems, provides term-level
                  abstraction supported by satisfiability modulo theories (SMT)
                  solvers, enables compositional reasoning, and implements the
                  paradigm of verification by reduction to synthesis, leveraging
                  the advances in algorithmic synthesis and machine learning. We
                  describe the key features of UCLID5 using illustrative
                  examples.},
  keywords =     {computability;formal specification;formal
                  verification;inference mechanisms;learning (artificial
                  intelligence);reasoning about programs;UCLID5;formal
                  methods;system design;transformative trends;data-driven
                  methods;traditional model-based design techniques;traditional
                  automated reasoning techniques;inductive inference;machine
                  learning;formal modeling;heterogeneous computational
                  systems;algorithmic synthesis;satisfiability modulo
                  theories;Formal methods;machine
                  learning;specification;verification;synthesis;hardware;software;cyber-physical
                  systems;security},
  doi =          {10.1109/MEMCOD.2018.8556946},
  ISSN =         {},
  month =        {Oct},
}

@article{hyperproperties:clarkson:jcs2010,
  title =        {Hyperproperties},
  author =       {Clarkson, Michael R and Schneider, Fred B},
  journal =      {Journal of Computer Security},
  volume =       {18},
  number =       {6},
  pages =        {1157--1210},
  year =         {2010},
  publisher =    {IOS Press}
}

@inproceedings{subramanyan:ccs2017,
  author =       {Subramanyan, Pramod and Sinha, Rohit and Lebedev, Ilia and
                  Devadas, Srinivas and Seshia, Sanjit A.},
  title =        {A Formal Foundation for Secure Remote Execution of Enclaves},
  booktitle =    {Proceedings of the 2017 ACM SIGSAC Conference on Computer and
                  Communications Security},
  series =       {CCS '17},
  year =         {2017},
  isbn =         {978-1-4503-4946-8},
  location =     {Dallas, Texas, USA},
  pages =        {2435--2450},
  numpages =     {16},
  url =          {http://doi.acm.org/10.1145/3133956.3134098},
  doi =          {10.1145/3133956.3134098},
  acmid =        {3134098},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {confidentiality, enclave programs, formal verification,
                  integrity, remote attestation, secure computation},
}
@inproceedings{tap:subramanyan:ccs2017,
  author =       {Subramanyan, Pramod and Sinha, Rohit and Lebedev, Ilia and
                  Devadas, Srinivas and Seshia, Sanjit A.},
  title =        {A Formal Foundation for Secure Remote Execution of Enclaves},
  booktitle =    {Proceedings of the 2017 ACM SIGSAC Conference on Computer and
                  Communications Security},
  series =       {CCS '17},
  year =         {2017},
  isbn =         {978-1-4503-4946-8},
  location =     {Dallas, Texas, USA},
  pages =        {2435--2450},
  numpages =     {16},
  url =          {http://doi.acm.org/10.1145/3133956.3134098},
  doi =          {10.1145/3133956.3134098},
  acmid =        {3134098},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {confidentiality, enclave programs, formal verification,
                  integrity, remote attestation, secure computation},
}
@inproceedings{tallent:nas2016,
  author =       {N. R. {Tallent} and K. J. {Barker} and R. {Gioiosa} and
                  A. {Marquez} and G. {Kestor} and L. {Song} and A. {Tumeo} and
                  D. J. {Kerbyson} and A. {Hoisie}},
  booktitle =    {2016 IEEE International Conference on Networking, Architecture
                  and Storage (NAS)},
  title =        {Assessing Advanced Technology in CENATE},
  year =         {2016},
  volume =       {},
  number =       {},
  pages =        {1-2},
  keywords =     {computer aided analysis;computerised instrumentation;digital
                  storage;learning (artificial
                  intelligence);microcomputers;network interfaces;performance
                  evaluation;silicon;simulation;switching networks;advanced
                  technology assessment;CENATE;PNNL center for advanced
                  technology evaluation;US Department of Energy center;computing
                  technology;processor socket;homogeneous systems;accelerated
                  systems;dynamic memories;static memories;memory
                  cubes;motherboards;network interface cards;switching
                  networks;input/output devices;storage devices;multiperspective
                  evaluation process;advanced system instrumentation;performance
                  measurement;modeling;simulation;network technology;silicon
                  photonics interconnection;Data Vortex
                  network;performance-power tradeoff analysis;machine learning
                  application;Instruments;Temperature measurement;Computer
                  architecture;Optical switches;Network topology;Computational
                  modeling},
  doi =          {10.1109/NAS.2016.7549392},
  ISSN =         {},
  month =        {Aug},
}

@inproceedings{transys:zhang:oakland2020,
  author =       {Rui Zhang and Cynthia Sturton},
  title =        {Transys: Leveraging Common Security Properties Across Hardware
                  Designs},
  booktitle =    {Proceedings of the Symposium on Security and Privacy (S\&P)},
  year =         {2020},
  publisher =    {IEEE}
}

@article{harris:fmsd2017,
  title =        {Program Synthesis For Interactive-Security Systems},
  author =       {Harris, William R and Jha, Somesh and Reps, Thomas W and
                  Seshia, Sanjit A},
  journal =      {Formal Methods in System Design},
  volume =       {51},
  number =       {2},
  pages =        {362--394},
  year =         {2017},
  publisher =    {Springer}
}

@article{thakur:tapas2013,
  title =        "PostHat and All That: Automating Abstract Interpretation",
  journal =      "Electronic Notes in Theoretical Computer Science",
  volume =       311,
  pages =        "15 - 32",
  year =         2015,
  note =         "Fourth Workshop on Tools for Automatic Program Analysis (TAPAS
                  2013)",
  issn =         "1571-0661",
  doi =          "https://doi.org/10.1016/j.entcs.2015.02.003",
  url =
                  "http://www.sciencedirect.com/science/article/pii/S1571066115000043",
  author =       "A. Thakur and A. Lal and J. Lim and T. Reps",
  keywords =     "abstract interpretation, invariant generation, symbolic
                  abstraction, decision procedures",
  abstract =     "Abstract interpretation provides an elegant formalism for
                  performing program analysis. Unfortunately, designing and
                  implementing a sound, precise, scalable, and extensible
                  abstract interpreter is difficult. In this paper, we describe
                  an approach to creating correct-by-construction abstract
                  interpreters that also attain the fundamental limits on
                  precision that abstract-interpretation theory establishes. Our
                  approach requires the analysis designer to implement only a
                  small number of operations. In particular, we describe a
                  systematic method for implementing an abstract interpreter
                  that solves the following problem: Given program P, and an
                  abstract domain A, find the most-precise inductive A-invariant
                  for P."
}

@Inbook{loginov:pactp2007,
  author =       "Loginov, Alexey and Reps, Thomas and Sagiv, Mooly",
  editor =       "Reps, Thomas and Sagiv, Mooly and Bauer, J{\"o}rg",
  title =        "Refinement-Based Verification for Possibly-Cyclic Lists",
  bookTitle =    "Program Analysis and Compilation, Theory and Practice: Essays
                  Dedicated to Reinhard Wilhelm on the Occasion of His 60th
                  Birthday",
  year =         "2007",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "247--272",
  abstract =     "In earlier work, we presented an abstraction-refinement
                  mechanism that was successful in verifying automatically the
                  partial correctness of in-situ list reversal when applied to
                  an acyclic linked list [10]. This paper reports on the
                  automatic verification of the total correctness (partial
                  correctness and termination) of the same list-reversal
                  algorithm, when applied to a possibly-cyclic linked list. A
                  key contribution that made this result possible is an
                  extension of the finite-differencing technique [14] to enable
                  the maintenance of reachability information for a restricted
                  class of possibly-cyclic data structures, which includes
                  possibly-cyclic linked lists.",
  isbn =         "978-3-540-71322-7",
  doi =          "10.1007/978-3-540-71322-7_12",
  url =          "https://doi.org/10.1007/978-3-540-71322-7_12"
}

@InProceedings{dawn:iss2008,
  author =       "Song, Dawn and Brumley, David and Yin, Heng and Caballero,
                  Juan and Jager, Ivan and Kang, Min Gyung and Liang, Zhenkai
                  and Newsome, James and Poosankam, Pongsin and Saxena, Prateek",
  editor =       "Sekar, R.  and Pujari, Arun K.",
  title =        "BitBlaze: A New Approach to Computer Security via Binary
                  Analysis",
  booktitle =    "Information Systems Security",
  year =         "2008",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "1--25",
  abstract =     "In this paper, we give an overview of the BitBlaze project, a
                  new approach to computer security via binary analysis. In
                  particular, BitBlaze focuses on building a unified binary
                  analysis platform and using it to provide novel solutions to a
                  broad spectrum of different security problems. The binary
                  analysis platform is designed to enable accurate analysis,
                  provide an extensible architecture, and combines static and
                  dynamic analysis as well as program verification techniques to
                  satisfy the common needs of security applications. By
                  extracting security-related properties from binary programs
                  directly, BitBlaze enables a principled, root-cause based
                  approach to computer security, offering novel and effective
                  solutions, as demonstrated with over a dozen different
                  security applications.",
  isbn =         "978-3-540-89862-7"
}

@InProceedings{jhala:cav2001,
  author =       "Jhala, Ranjit and McMillan, Kenneth L.",
  editor =       "Berry, G{\'e}rard and Comon, Hubert and Finkel, Alain",
  title =        "Microarchitecture Verification by Compositional Model
                  Checking",
  booktitle =    "Computer Aided Verification",
  year =         "2001",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "396--410",
  abstract =     "Compositional model checking is used to verify a processor
                  microarchitecture containing most of the features of a modern
                  microprocessor, including branch prediction, speculative
                  execution, out-of-order execution and a load-store buffer
                  supporting re-ordering and load forwarding. We observe that
                  the proof methodology scales well, in that the incremental
                  proof cost of each feature is low. The proof is also quite
                  concise with respect to proofs of similar microarchitecture
                  models using other methods.",
  isbn =         "978-3-540-44585-2"
}

@InProceedings{mcmillan:chdvm1999,
  author =       "McMillan, K. L.",
  editor =       "Pierre, Laurence and Kropf, Thomas",
  title =        "Verification of Infinite State Systems by Compositional Model
                  Checking",
  booktitle =    "Correct Hardware Design and Verification Methods",
  year =         "1999",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "219--237",
  abstract =     "A method of compositional verification is presented that uses
                  the combination of temporal case splitting and data type
                  reductions to reduce types of infinite or unbounded range to
                  small finite types, and arrays of infinite or unbounded size
                  to small fixed-size arrays. This supports the verification by
                  model checking of systems with unbounded resources and
                  uninterpreted functions. The method is illustrated by
                  application to an implementation of Tomasulo's algorithm, for
                  arbitrary or infinite word size, register file size, number of
                  reservation stations and number of execution units.",
  isbn =         "978-3-540-48153-9"
}

@inproceedings{reid:fmcad2016,
  author =       {A. {Reid}},
  booktitle =    {2016 Formal Methods in Computer-Aided Design (FMCAD)},
  title =        {Trustworthy specifications of ARM® v8-A and v8-M system level
                  architecture},
  year =         {2016},
  volume =       {},
  number =       {},
  pages =        {161-168},
  abstract =     {Processor specifications are of critical importance for
                  verifying programs, compilers, operating systems/hypervisors,
                  and, of course, for verifying microprocessors themselves. But
                  to be useful, the scope of these specifications must be
                  sufficient for the task, the specification must be applicable
                  to processors of interest and the specification must be
                  trustworthy. This paper describes a 5 year project to change
                  ARM's existing architecture specification process so that
                  machine-readable, executable specifications can be
                  automatically generated from the same materials used to
                  generate ARM's conventional architecture documentation. We
                  have developed executable specifications of both ARM's A-class
                  and M-class processor architectures that are complete enough
                  and trustworthy enough that we have used them to formally
                  verify ARM processors using bounded model checking. In
                  particular, our specifications include the semantics of the
                  most security sensitive parts of the processor: the memory and
                  register protection mechanisms and the exception mechanisms
                  that trigger transitions between different modes. Most
                  importantly, we have applied a diverse set of methods
                  including ARM's internal processor test suites to improve our
                  trust in the specification using many other expressions of the
                  architectural specification such as ARM's simulators,
                  testsuites and processors to defend against common-mode
                  failure. In the process, we have also found bugs in all those
                  artifacts: testing specifications is very much a two-way
                  street. While there have been previous specifications of ARM
                  processors, their scope has excluded the system architecture,
                  their applicability has excluded newer processors and M-class,
                  and their trustworthiness has not been established as
                  thoroughly. Our focus has been on enabling the formal
                  verification of ARM processors but, recognising the value of
                  this specification for verifying software, we are currently
                  preparing a public release of the machine-readable
                  specification.},
  keywords =     {data protection;formal specification;formal
                  verification;software architecture;trusted
                  computing;trustworthy specification;ARMR v8-A;ARMR v8-M;system
                  level architecture;processor specification;architecture
                  specification process;memory protection mechanism;register
                  protection mechanism;exception mechanism;formal
                  verification;machine-readable specification;Program
                  processors;Computer
                  architecture;Registers;Encoding;Documentation;Testing;Syntactics},
  doi =          {10.1109/FMCAD.2016.7886675},
  ISSN =         {},
  month =        {Oct},
}

@inproceedings{reid:cav2016,
  author =       "Reid, Alastair and Chen, Rick and Deligiannis, Anastasios and
                  Gilday, David and Hoyes, David and Keen, Will and Pathirane,
                  Ashan and Shepherd, Owen and Vrabel, Peter and Zaidi, Ali",
  editor =       "Chaudhuri, Swarat and Farzan, Azadeh",
  title =        "End-to-End Verification of Processors with ISA-Formal",
  booktitle =    "Computer Aided Verification",
  year =         "2016",
  publisher =    "Springer International Publishing",
  address =      "Cham",
  pages =        "42--58",
  abstract =     "Despite 20+ years of research on processor verification, it
                  remains hard to use formal verification techniques in
                  commercial processor development. There are two significant
                  factors: scaling issues and return on investment. The scaling
                  issues include the size of modern processor specifications,
                  the size/complexity of processor designs, the size of
                  design/verification teams and the (non)availability of enough
                  formal verification experts. The return on investment issues
                  include the need to start catching bugs early in development,
                  the need to continue catching bugs throughout development, and
                  the need to be able to reuse verification IP, tools and
                  techniques across a wide range of design styles.",
  isbn =         "978-3-319-41540-6"
}

@InProceedings{bhattacharya:chdvm2005,
  author =       "Bhattacharya, Ritwik and German, Steven and Gopalakrishnan,
                  Ganesh",
  editor =       "Borrione, Dominique and Paul, Wolfgang",
  title =        "Symbolic Partial Order Reduction for Rule Based Transition
                  Systems",
  booktitle =    "Correct Hardware Design and Verification Methods",
  year =         "2005",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "332--335",
  abstract =     "Partial order (PO) reduction methods are widely employed to
                  combat state explosion during model-checking. We develop a
                  partial order reduction algorithm for rule-based languages
                  such as Murphi [4] based on the observation that for
                  finite-state systems, independence conditions used for PO
                  reduction can be encoded as boolean propositions and checked
                  using SAT methods. Comparisons against static-analysis based
                  PO reduction algorithms have yielded encouraging results.",
  isbn =         "978-3-540-32030-2"
}

@Article{chen:fmsd2010,
  author =       "Chen, Xiaofang and Yang, Yu and Gopalakrishnan, Ganesh and
                  Chou, Ching-Tsun",
  title =        "Efficient methods for formally verifying safety properties of
                  hierarchical cache coherence protocols",
  journal =      "Formal Methods in System Design",
  year =         "2010",
  month =        "Feb",
  day =          "01",
  volume =       "36",
  number =       "1",
  pages =        "37--64",
  abstract =     "Multicore architectures are considered inevitable, given that
                  sequential processing hardware has hit various
                  limits. Unfortunately, the memory system of multicore
                  processors is a huge bottleneck. To combat this problem, one
                  needs to design aggressively optimized cache coherence
                  protocols. This introduces the design correctness problem for
                  advanced cache coherence protocols which will be
                  hierarchically organized for scalable designs. Experiences
                  show that monolithic formal verification will not scale to
                  hierarchical designs. Hence, one needs to handle the
                  complexity of several coherence protocols running
                  concurrently, i.e. hierarchical protocols, using compositional
                  techniques.",
  issn =         "1572-8102",
  doi =          "10.1007/s10703-010-0092-y",
  url =          "https://doi.org/10.1007/s10703-010-0092-y"
}

@InProceedings{vijayaraghavan:cav2015,
  author =       "Vijayaraghavan, Muralidaran and Chlipala, Adam and Arvind and Dave, Nirav",
  editor =       "Kroening, Daniel and P{\u{a}}s{\u{a}}reanu, Corina S.",
  title =        "Modular Deductive Verification of Multiprocessor Hardware Designs",
  booktitle =    "Computer Aided Verification",
  year =         "2015",
  publisher =    "Springer International Publishing",
  address =      "Cham",
  pages =        "109--127",
  abstract =     "We present a new framework for modular verification of hardware designs in the
                  style of the Bluespec language. That is, we formalize the idea of components in a
                  hardware design, with well-defined input and output channels; and we show how to
                  specify and verify components individually, with machine-checked proofs in the Coq
                  proof assistant. As a demonstration, we verify a fairly realistic implementation
                  of a multicore shared-memory system with two types of components: memory system
                  and processor. Both components include nontrivial optimizations, with the memory
                  system employing an arbitrary hierarchy of cache nodes that communicate with each
                  other concurrently, and with the processor doing speculative execution of many
                  concurrent read operations. Nonetheless, we prove that the combined system
                  implements sequential consistency. To our knowledge, our memory-system proof is
                  the first machine verification of a cache-coherence protocol parameterized over an
                  arbitrary cache hierarchy, and our full-system proof is the first machine
                  verification of sequential consistency for a multicore hardware design that
                  includes caches and speculative processors.",
  isbn =         "978-3-319-21668-3"
}

@INPROCEEDINGS{checkmate:trippel:micro2018,
  author =       {C. {Trippel} and D. {Lustig} and M. {Martonosi}},
  booktitle =    {2018 51st Annual IEEE/ACM International Symposium on Microarchitecture (MICRO)},
  title =        {CheckMate: Automated Synthesis of Hardware Exploits and Security Litmus Tests},
  year =         {2018},
  volume =       {},
  number =       {},
  pages =        {947-960},
  abstract =     {Recent research has uncovered a broad class of security vulnerabilities in which
                  confidential data is leaked through programmer-observable microarchitectural
                  state. In this paper, we present CheckMate, a rigorous approach and automated tool
                  for determining if a microarchitecture is susceptible to specified classes of
                  security exploits, and for synthesizing proof-of-concept exploit code when it
                  is. Our approach adopts "microarchitecturally happens-before" (μhb) graphs which
                  prior work designed to capture the subtle orderings and interleavings of hardware
                  execution events when programs run on a microarchitecture. CheckMate extends μhb
                  graphs to facilitate modeling of security exploit scenarios and hardware execution
                  patterns indicative of classes of exploits. Furthermore, it leverages relational
                  model finding techniques to enable automated exploit program synthesis from
                  microarchitecture and exploit pattern specifications. As a case study, we use
                  CheckMate to evaluate the susceptibility of a speculative out-of-order processor
                  to Flush+Reload cache side-channel attacks. The automatically synthesized results
                  are programs representative of Meltdown and Spectre attacks. We then evaluate the
                  same processor on its susceptibility to a different timing side-channel attack:
                  Prime+Probe. Here, CheckMate synthesized new exploits that are similar to Meltdown
                  and Spectre in that they leverage speculative execution, but unique in that they
                  exploit distinct microarchitectural behaviors-speculative cache line invalidations
                  rather than speculative cache pollution-to form a side-channel. Most importantly,
                  our results validate the CheckMate approach to formal hardware security
                  verification and the ability of the CheckMate tool to detect real-world
                  vulnerabilities.},
  keywords =     {cache storage;data privacy;program diagnostics;program verification;security of
                  data;program synthesis;microarchitecture;pattern specifications;out-of-order
                  processor;Flush+Reload cache side-channel attacks;formal hardware security
                  verification;CheckMate tool;security litmus tests;security
                  vulnerabilities;confidential data;programmer-observable microarchitectural
                  state;automated tool;security exploits;hardware execution events;μhb
                  graphs;hardware execution patterns;cache pollution;hardware exploits automated
                  synthesis;timing side-channel attack;microarchitecturally happens-before
                  graphs;relational model finding techniques;automated exploit program
                  synthesis;Spectre attacks;Meltdown attacks;Prime+Probe;speculative cache line
                  invalidations;Microarchitecture;Hardware;Side-channel
                  attacks;Timing;Tools;Kernel;hardware security, automated verification, relational
                  model finding, exploit synthesis, side-channel attacks},
  doi =          {10.1109/MICRO.2018.00081},
  ISSN =         {},
  month =        {Oct},
}

@InProceedings{lynce:sat2005,
  author =       {Lynce, {I}. and Marques-Silva, {J}.},
  title =        {On Computing Minimum Unsatisfiable Cores},
  publisher =    {LNCS},
  year =         {2004},
  volume =       {3542},
  pages =        {305-310},
  booktitle =    {7th International Conference on Theory and Applications of Satisfiability Testing
                  (SAT-2004)},
  abstract =     {Certifying a SAT solver for unsatisfiable instances is a computationally hard
                  problem. Nevertheless, in the utilization of SAT in industrial settings, one often
                  needs to be able to generate unsatisfiability proofs, either to guarantee the
                  correctness of the SAT solver or as part of the utilization of SAT in some
                  applications (e.g. in model checking). As part of the process of generating
                  unsatisfiable proofs, one is also interested in unsatisfiable sub- formulas of the
                  original formula, also known as unsatisfiable cores. Furthermore, it may by useful
                  identifying the minimum unsatisfiable core of a given problem instance, i.e. the
                  smallest number of clauses that make the instance unsatisfiable. This approach is
                  be very useful in AI problems where identifying the minimum core is crucial for
                  correcting the minimum amount of inconsistent information (e.g. in knowledge
                  bases).},
}

@INPROCEEDINGS{uci:hicks:oakland2010,
  author =       {M. {Hicks} and M. {Finnicum} and S. T. {King} and M. M. K. {Martin}
                  and J. M. {Smith}},
  booktitle =    {2010 IEEE Symposium on Security and Privacy},
  title =        {Overcoming an Untrusted Computing Base: Detecting and Removing
                  Malicious Hardware Automatically},
  year =         {2010},
  volume =       {},
  number =       {},
  pages =        {159-172},
  keywords =     {exception handling;hardware-software codesign;program
                  verification;security of data;untrusted computing base;malicious
                  hardware removal;computer systems security;hardware
                  complexity;hardware based security threats;hybrid hardware-software
                  approach;BlueChip;design verification phase;unused circuit
                  identification;exception generation hardware;exception handler
                  software;Hardware;Circuit testing;Computer security;Process
                  design;Runtime;Costs;Logic;Algorithm design and
                  analysis;Privacy;Arm},
  doi =          {10.1109/SP.2010.18},
  ISSN =         {},
  month =        {May},
}

@ARTICLE{veritrust:zhang:tcad2015,
  author =       {J. {Zhang} and F. {Yuan} and L. {Wei} and Y. {Liu} and Q. {Xu}},
  journal =      {IEEE Transactions on Computer-Aided Design of Integrated Circuits
                  and Systems},
  title =        {VeriTrust: Verification for Hardware Trust},
  year =         {2015},
  volume =       {34},
  number =       {7},
  pages =        {1148-1161},
  abstract =     {Today's integrated circuit designs are vulnerable to a wide range
                  of malicious alterations, namely hardware Trojans (HTs). HTs serve
                  as backdoors to subvert or augment the normal operation of infected
                  devices, which may lead to functionality changes, sensitive
                  information leakages, or denial of service attacks. To tackle such
                  threats, this paper proposes a novel verification technique for
                  hardware trust, namely VeriTrust, which facilitates to detect HTs
                  inserted at design stage. Based on the observation that HTs are
                  usually activated by dedicated trigger inputs that are not
                  sensitized with verification test cases, VeriTrust automatically
                  identifies such potential HT trigger inputs by examining
                  verification corners. The key difference between VeriTrust and
                  existing HT detection techniques based on “unused circuit
                  identification” is that VeriTrust is insensitive to the
                  implementation style of HTs. Experimental results show that
                  VeriTrust is able to detect all HTs evaluated in this paper
                  (constructed based on various HT design methodologies shown in this
                  paper) at the cost of moderate extra verification time.},
  keywords =     {integrated circuit design;security;verification time;HT design
                  methodology;unused circuit identification;HT detection technique;HT
                  trigger inputs;infected devices;denial-of-service
                  attacks;information leakages;hardware Trojans;integrated circuit
                  designs;hardware trust verification;VeriTrust;Hardware;Frequency
                  modulation;Measurement;Integrated circuit modeling;Design
                  methodology;Hardware design languages;Hardware Trojan;Hardware
                  Trust;Design Verification;Design verification;hardware Trojan
                  (HT);hardware trust},
  doi =          {10.1109/TCAD.2015.2422836},
  ISSN =         {},
  month =        {July},
}
@ARTICLE{sellers:tc1968,
  author =       {F. F. {Sellers} and M. Y. {Hsiao} and L. W. {Bearnson}},
  journal =      {IEEE Transactions on Computers},
  title =        {Analyzing Errors with the Boolean Difference},
  year =         {1968},
  volume =       {C-17},
  number =       {7},
  pages =        {676-683},
  abstract =     {Abstract—The Boolean difference is defined. It is shown through
                  example how the Boolean difference is used to analyze the effect of
                  errors on the outputs of logic circuits. Examples are given of
                  error detection problems, analysis of redundant logic, and the
                  generation of diagnostic sequences.},
  keywords =     {Index terms—Boolean algebra, Boolean difference, diagnostic
                  program, error analysis, error correction, error detection, logic
                  analysis, logic design.;Index terms—Boolean algebra, Boolean
                  difference, diagnostic program, error analysis, error correction,
                  error detection, logic analysis, logic design.},
  doi =          {10.1109/TC.1968.227417},
  ISSN =         {2326-3814},
  month =        {July},
}

@inproceedings{sva:criswell:sosp2007,
  author =       {Criswell, John and Lenharth, Andrew and Dhurjati, Dinakar and Adve,
                  Vikram},
  title =        {Secure Virtual Architecture: A Safe Execution Environment for
                  Commodity Operating Systems},
  booktitle =    {Proceedings of Twenty-first ACM SIGOPS Symposium on Operating
                  Systems Principles},
  series =       {SOSP '07},
  year =         {2007},
  isbn =         {978-1-59593-591-5},
  location =     {Stevenson, Washington, USA},
  pages =        {351--366},
  numpages =     {16},
  url =          {http://doi.acm.org/10.1145/1294261.1294295},
  doi =          {10.1145/1294261.1294295},
  acmid =        {1294295},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {compiler, memory safety, operating systems, security, type safety,
                  typed assembly language, virtual machine},
} 

@inproceedings{svaos:criswell:ssym2009,
 author = {Criswell, John and Geoffray, Nicolas and Adve, Vikram},
 title = {Memory Safety for Low-level Software/Hardware Interactions},
 booktitle = {Proceedings of the 18th Conference on USENIX Security Symposium},
 series = {SSYM'09},
 year = {2009},
 location = {Montreal, Canada},
 pages = {83--100},
 numpages = {18},
 url = {http://dl.acm.org/citation.cfm?id=1855768.1855774},
 acmid = {1855774},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
} 

@inproceedings{virtualghost:criswell:asplos2014,
  author =       {Criswell, John and Dautenhahn, Nathan and Adve, Vikram},
  title =        {Virtual Ghost: Protecting Applications from Hostile Operating
                  Systems},
  booktitle =    {Proceedings of the 19th International Conference on Architectural
                  Support for Programming Languages and Operating Systems},
  series =       {ASPLOS '14},
  year =         {2014},
  isbn =         {978-1-4503-2305-5},
  location =     {Salt Lake City, Utah, USA},
  pages =        {81--96},
  numpages =     {16},
  url =          {http://doi.acm.org/10.1145/2541940.2541986},
  doi =          {10.1145/2541940.2541986},
  acmid =        {2541986},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {control-flow integrity, inlined reference monitors, malicious
                  operating systems, software fault isolation, software security},
}

@misc{AMDErrata:14hModels00h-0Fh-Rev-3-18,
  Author =       {Advanced Micro Devices Inc.},
  Title =        {Revision Guide for {AMD} Family 14h Models 00h-0Fh Processors},
  Number =       {47534},
  Month =        {February},
  Year =         {2013},
}                  

@misc{IntelErrata:7thGenFamily,
  Author =       {\relax Intel Corporation},
  Title =        {7th Generation Intel{\textregistered} Processor Family
                  Specification Update},
  Number =       {334663-004},
  Month =        {February},
  Year =         {2017},
  URL =
                  {https://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/7th-gen-core-family-spec-update.pdf},
}

@inproceedings{shade:johnson:vee2019,
  author =       {Johnson, Ethan and Dharsee, Komail and Criswell, John},
  title =        {{Secure Guest Virtual Machine Support in Apparition}},
  booktitle =    {Proceedings of the 15th ACM SIGPLAN/SIGOPS International Conference
                  on Virtual Execution Environments},
  series =       {VEE 2019},
  year =         {2019},
  isbn =         {978-1-4503-6020-3},
  location =     {Providence, RI, USA},
  pages =        {17--30},
  numpages =     {14},
  url =          {http://doi.acm.org/10.1145/3313808.3313809},
  doi =          {10.1145/3313808.3313809},
  acmid =        {3313809},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {compiler-based virtual machines, hypervisor security, hypervisors,
                  secure computer architectures, side channels, trusted execution
                  environments, untrusted hypervisor},
}


@inproceedings{apparition:dong:ssym2018,
  author =       {Dong, Xiaowan and Shen, Zhuojia and Criswell, John and Cox, Alan
                  L. and Dwarkadas, Sandhya},
  title =        {Shielding Software From Privileged Side-Channel Attacks},
  booktitle =    {Proceedings of the 27th USENIX Security Symposium},
  series =       {Security'18},
  year =         {2018},
  isbn =         {978-1-931971-46-1},
  location =     {Baltimore, MD},
  pages =        {1441--1458},
  numpages =     {18},
  url =
                  {https://www.usenix.org/conference/usenixsecurity18/presentation/dong},
}

@inproceedings{fanci-waksman-ccs2013,
  author =       {Waksman, Adam and Suozzo, Matthew and Sethumadhavan, Simha},
  title =        {FANCI: Identification of Stealthy Malicious Logic Using Boolean
                  Functional Analysis},
  booktitle =    {Proceedings of the 2013 ACM SIGSAC Conference on Computer \&\#38;
                  Communications Security},
  series =       {CCS '13},
  year =         {2013},
  isbn =         {978-1-4503-2477-9},
  location =     {Berlin, Germany},
  pages =        {697--708},
  numpages =     {12},
  url =          {http://doi.acm.org/10.1145/2508859.2516654},
  doi =          {10.1145/2508859.2516654},
  acmid =        {2516654},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {backdoors, functional analysis, hardware, intellectual property,
                  security},
}

@InProceedings{petunia:dharsee:secdev2017,
  author =       {Komail Dharsee and Ethan Johnson and John Criswell},
  booktitle =    {2017 IEEE Cybersecurity Development (SecDev)},
  title =        {A Software Solution for Hardware Vulnerabilities},
  year =         {2017},
  volume =       {},
  number =       {},
  pages =        {27-33},
  doi =          {10.1109/SecDev.2017.18},
  month =        {Sept}
}

@Inbook{moore:fmatc2003,
  author =       "Moore, J. Strother",
  editor =       "Aichernig, Bernhard K.  and Maibaum, Tom",
  title =        "A Grand Challenge Proposal for Formal Methods: A Verified Stack",
  bookTitle =    "Formal Methods at the Crossroads. From Panacea to Foundational
                  Support: 10th Anniversary Colloquium of UNU/IIST, the International
                  Institute for Software Technology of The United Nations University,
                  Lisbon, Portugal, March 18-20, 2002. Revised Papers",
  year =         "2003",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "161--172",
  abstract =     "We propose a grand challenge for the formal methods community:
                  build and mechanically verify a practical computing system, from
                  transistors to software. The challenge is both competitive and
                  collaborative. It is collaborative because practical systems are
                  too large for any one group or tool to handle in isolation:groups
                  will have to team together. Furthermore, the vertical integration
                  of systems at different levels of abstractions -- from transistors
                  to software -- will encourage the team to adopt different tools for
                  different levels and connect them. It is competitive because there
                  are many systems from which to choose and different teams may form
                  around different target systems.",
  isbn =         "978-3-540-40007-3",
  doi =          "10.1007/978-3-540-40007-3_11",
  url =          "https://doi.org/10.1007/978-3-540-40007-3_11"
}

@incollection{boyer:ara1997,
  author =       {Boyer, Robert S. and Moore, J. Strother},
  chapter =      {Mechanized Formal Reasoning About Programs and Computing Machines},
  title =        {Automated Reasoning and Its Applications},
  editor =       {Veroff, Robert and Pieper, Gail W.},
  year =         {1997},
  isbn =         {0-262-22055-5},
  pages =        {147--176},
  numpages =     {30},
  url =          {http://dl.acm.org/citation.cfm?id=271101.271126},
  acmid =        {271126},
  publisher =    {MIT Press},
  address =      {Cambridge, MA, USA},
} 

@book{hwsec:bhunia:mkpi2018,
  author =       {Bhunia, Swarup and Tehranipoor, Mark},
  title =        {Hardware Security: A Hands-on Learning Approach},
  year =         {2018},
  isbn =         {0128124776, 9780128124772},
  edition =      {1st},
  publisher =    {Morgan Kaufmann Publishers Inc.},
  address =      {San Francisco, CA, USA},
} 

@inproceedings{trusthub:salmani:iccd2013,
  author =       {H. {Salmani} and M. {Tehranipoor} and R. {Karri}},
  booktitle =    {2013 IEEE 31st International Conference on Computer Design (ICCD)},
  title =        {On design vulnerability analysis and trust benchmarks development},
  year =         {2013},
  volume =       {},
  number =       {},
  pages =        {471-474},
  keywords =     {invasive software;trusted computing;design vulnerability
                  analysis;trust benchmark development;hardware security;Trojan
                  detection;Trojan prevention;vulnerability analysis flow;production
                  test;extensive functional test analysis;Trojan detectability
                  metric;Trojan activation quantification;Trojan effect
                  quantification;weakness analysis;strength analysis;Trojan
                  horses;Delays;Benchmark testing;Hardware;Capacitance;Logic gates},
  doi =          {10.1109/ICCD.2013.6657085},
  ISSN =         {1063-6404},
  month =        {Oct},
}

@article{skolem:logico1879,
  title =        {Logico-combinatorial investigations in the satisfiability or
                  provability of mathematical propositions: a simplified proof of a
                  theorem by L. L{\"o}wenheim and generalizations of the theorem},
  author =       {Skolem, Thoralf},
  journal =      {From Frege to G{\"o}del. A Source Book in Mathematical Logic},
  volume =       {1931},
  pages =        {252--263},
  year =         {1879}
}
@INPROCEEDINGS{goguen:oakland1982,
  author =       {J. A. {Goguen} and J. {Meseguer}},
  booktitle =    {1982 IEEE Symposium on Security and Privacy},
  title =        {Security Policies and Security Models},
  year =         {1982},
  volume =       {},
  number =       {},
  pages =        {11-11},
  keywords =     {Computational modeling;Automata;Finite element methods;Mathematical
                  model;Data models;Computers;Message systems},
  doi =          {10.1109/SP.1982.10014},
  ISSN =         {1540-7993},
  month =        {April},
}


@article{brown:founda1996,
  title =        {Foundations without Foundationalism: A Case for Second-Order
                  LogicStewart Shapiro Oxford: Oxford University Press, 1991, xx 277
                  pp.},
  volume =       {35},
  DOI =          {10.1017/S0012217300008945},
  number =       {3},
  journal =      {Dialogue},
  publisher =    {Cambridge University Press},
  author =       {Brown, James Robert},
  year =         {1996},
  pages =        {624–626}
}

@inproceedings{jifeng:esop1986,
  title =        {Data refinement refined},
  author =       {Jifeng, He and Hoare, CAR and Sanders, Jeff W},
  booktitle =    {Proc. EsOP},
  volume =       {86},
  pages =        {187--196},
  year =         {1986}
}

@article{hoare:actainf1972,
  author =       {Hoare, C. A.},
  title =        {Proof of Correctness of Data Representations},
  year =         {1972},
  issue_date =   {December 1972},
  publisher =    {Springer-Verlag},
  address =      {Berlin, Heidelberg},
  volume =       {1},
  number =       {4},
  issn =         {0001-5903},
  url =          {https://doi.org/10.1007/BF00289507},
  doi =          {10.1007/BF00289507},
  journal =      {Acta Inf.},
  month =        dec,
  pages =        {271–281},
  numpages =     {11}
}

@article{abadi:tcs1991,
  title =        "The existence of refinement mappings",
  journal =      "Theoretical Computer Science",
  volume =       "82",
  number =       "2",
  pages =        "253 - 284",
  year =         "1991",
  issn =         "0304-3975",
  doi =          "https://doi.org/10.1016/0304-3975(91)90224-P",
  url =          "http://www.sciencedirect.com/science/article/pii/030439759190224P",
  author =       "Martín Abadi and Leslie Lamport",
  abstract =     "Refinement mappings are used to prove that a lower-level
                  specification correctly implements a higher-level one. We consider
                  specifications consisting of a state machine (which may be
                  infinite- state) that specifies safety requirements, and an
                  arbitrary supplementary property that specifies liveness
                  requirements. A refinement mapping from a lower-level specification
                  S1 to a higher-level one S2 is a mapping from S1's state space to
                  S2's state space. It maps steps of S1's state machine to steps of
                  S2's state machine and maps behaviors allowed by S1 to behaviors
                  allowed by S2. We show that, under reasonable assumptions about the
                  specification, if S1 implements S2, then by adding auxiliary
                  variables to S1 we can guarantee the existence of a refinement
                  mapping. This provides a completeness result for a practical,
                  hierarchical specification method."
}
@article{michael:tams1951,
  ISSN =         {00029947},
  URL =          {http://www.jstor.org/stable/1990864},
  author =       {Ernest Michael},
  journal =      {Transactions of the American Mathematical Society},
  number =       {1},
  pages =        {152--182},
  publisher =    {American Mathematical Society},
  title =        {Topologies on Spaces of Subsets},
  volume =       {71},
  year =         {1951}
}

@article{mclean:tse1996,
  author =       {McLean, John},
  title =        {A General Theory of Composition for a Class of “Possibilistic”
                  Properties},
  year =         {1996},
  issue_date =   {January 1996},
  publisher =    {IEEE Press},
  volume =       {22},
  number =       {1},
  issn =         {0098-5589},
  url =          {https://doi.org/10.1109/32.481534},
  doi =          {10.1109/32.481534},
  journal =      {IEEE Trans. Softw. Eng.},
  month =        jan,
  pages =        {53–67},
  numpages =     {15},
  keywords =     {composition, information flow., security models, Computer security}
}

@INPROCEEDINGS{mantel:oakland2001,
  author =       {H. {Mantel}},
  booktitle =    {Proceedings 2001 IEEE Symposium on Security and Privacy. S P 2001},
  title =        {Preserving information flow properties under refinement},
  year =         {2001},
  volume =       {},
  number =       {},
  pages =        {78-91},
  keywords =     {security of data;safety;information flow property
                  preservation;refinement operators;stepwise development
                  process;safety;liveness;information flow;data security;Information
                  security;Safety;Artificial intelligence;Concrete},
  doi =          {10.1109/SECPRI.2001.924289},
  ISSN =         {1081-6011},
  month =        {May},
}

@INPROCEEDINGS{bossi:sefm2003,
  author =       {A. {Bossi} and R. {Focardi} and C. {Piazza} and S. {Rossi}},
  booktitle =    {First International Conference on Software Engineering and Formal
                  Methods, 2003.Proceedings.},
  title =        {Refinement operators and information flow security},
  year =         {2003},
  volume =       {},
  number =       {},
  pages =        {44-53},
  keywords =     {security of data;refinement calculus;formal
                  specification;refinement operators;information flow
                  security;security process algebra;complex system
                  development;abstract specification;process refinement;system
                  security;Information
                  security;Concrete;Algebra;Protection;Sufficient
                  conditions;Interference constraints},
  doi =          {10.1109/SEFM.2003.1236206},
  ISSN =         {null},
  month =        {Sep.},
}

@article{alpern:ipl1985,
  title =        "Defining liveness",
  journal =      "Information Processing Letters",
  volume =       "21",
  number =       "4",
  pages =        "181 - 185",
  year =         "1985",
  issn =         "0020-0190",
  doi =          "https://doi.org/10.1016/0020-0190(85)90056-0",
  url =          "http://www.sciencedirect.com/science/article/pii/0020019085900560",
  author =       "Bowen Alpern and Fred B. Schneider",
  keywords =     "Liveness, absolute liveness, uniform liveness, safety, property,
                  topology, concurrency, semantics",
  abstract =     "A formal definition for liveness properties is proposed. It is
                  argued that this definition captures the intuition that liveness
                  properties stipulate that ‘something good’ eventually happens
                  during execution. A topological characterization of safety and
                  liveness is given. Every property is shown to be the intersection
                  of a safety property and a liveness property."
}

@misc{spectre:mcilroy:arXiv2019,
  title =        {Spectre is here to stay: An analysis of side-channels and
                  speculative execution},
  author =       {Ross Mcilroy and Jaroslav Sevcik and Tobias Tebbi and Ben L. Titzer
                  and Toon Verwaest},
  year =         {2019},
  eprint =       {1902.05178},
  archivePrefix ={arXiv},
  primaryClass = {cs.PL}
}

@inproceedings{stankaitis:hase2019,
  author =       {P. {Stankaitis} and A. {Iliasov} and Y. {Ait-Ameur} and
                  T. {Kobayashi} and F. {Ishikawa} and A. {Romanovsky}},
  booktitle =    {2019 IEEE 19th International Symposium on High Assurance Systems
                  Engineering (HASE)},
  title =        {A Refinement Based Method for Developing Distributed Protocols},
  year =         {2019},
  volume =       {},
  number =       {},
  pages =        {90-97},
  abstract =     {This paper presents a methodology for modelling and verification of
                  high-assurance distributed protocols. In the paper we describe two
                  main technical contributions needed for the development method:
                  communication modelling patterns and a refinement strategy. The
                  applicability of the proposed method is demonstrated by developing
                  a new distributed resource allocation protocol. We also discuss the
                  necessity of integrating other tools such as stochastic model
                  checkers for enabling verification of wider range of protocol
                  properties.},
  keywords =     {distributed processing;formal verification;protocols;resource
                  allocation;stochastic processes;development method;communication
                  modelling patterns;refinement strategy;distributed resource
                  allocation protocol;stochastic model checkers;protocol
                  properties;high-assurance distributed protocol
                  modelling;high-assurance distributed protocol
                  verification;Protocols;Mathematical model;Resource
                  management;Tools;Indexes;Modeling;System recovery;distributed
                  protocols;formal verification;Event B},
  doi =          {10.1109/HASE.2019.00023},
  ISSN =         {1530-2059},
  month =        {Jan},
}
@article{alpuim:scp2018,
  title =        "Embedding the refinement calculus in Coq",
  journal =      "Science of Computer Programming",
  volume =       "164",
  pages =        "37 - 48",
  year =         "2018",
  note =         "Special issue of selected papers from FLOPS 2016",
  issn =         "0167-6423",
  doi =          "https://doi.org/10.1016/j.scico.2017.04.003",
  url =          "http://www.sciencedirect.com/science/article/pii/S0167642317300710",
  author =       "João Alpuim and Wouter Swierstra",
  keywords =     "Refinement calculus, Coq, Predicate transformers, Free monad,
                  Dependent types",
  abstract =     "The refinement calculus and type theory are both frameworks that
                  support the specification and verification of programs. This paper
                  presents an embedding of the refinement calculus in the interactive
                  theorem prover Coq, clarifying the relation between the two. As a
                  result, refinement calculations can be performed in Coq, enabling
                  the interactive calculation of formally verified programs from
                  their specification."
}

@inproceedings{jiyong:micro2019,
  author =       {Yu, Jiyong and Yan, Mengjia and Khyzha, Artem and Morrison, Adam
                  and Torrellas, Josep and Fletcher, Christopher W.},
  title =        {Speculative Taint Tracking (STT): A Comprehensive Protection for
                  Speculatively Accessed Data},
  year =         {2019},
  isbn =         {9781450369381},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3352460.3358274},
  doi =          {10.1145/3352460.3358274},
  booktitle =    {Proceedings of the 52nd Annual IEEE/ACM International Symposium on
                  Microarchitecture},
  pages =        {954–968},
  numpages =     {15},
  keywords =     {Information flow, Speculative execution attacks, Security,
                  Hardware},
  location =     {Columbus, OH, USA},
  series =       {MICRO ’52}
}

@inproceedings{villa:micro2019,
  author =       {Oreste Villa and Mark Stephenson and David W. Nellans and Stephen
                  W. Keckler},
  title =        {NVBit: {A} Dynamic Binary Instrumentation Framework for {NVIDIA}
                  GPUs},
  booktitle =    {Proceedings of the 52nd Annual {IEEE/ACM} International Symposium
                  on Microarchitecture, {MICRO} 2019, Columbus, OH, USA, October
                  12-16, 2019},
  pages =        {372--383},
  year =         {2019},
  crossref =     {DBLP:conf/micro/2019},
  url =          {https://doi.org/10.1145/3352460.3358307},
  doi =          {10.1145/3352460.3358307},
  timestamp =    {Wed, 16 Oct 2019 10:12:02 +0200},
  biburl =       {https://dblp.org/rec/bib/conf/micro/VillaSNK19},
  bibsource =    {dblp computer science bibliography, https://dblp.org}
}


@book{IntelArchManual19,
  author = {Intel},
  Title={{Intel 64 and IA-32 Architectures Software Developer's Manual}},
  Month={November},
  Year={2019},
  note={325462-067US}
}

@book{AMDArchManual17,
  author = {{Advanced Micro Devices}},
  Title={{AMD64 Architecture Programmer's Manual}},
  Month={December},
  Year={2017}
}

@article{florence:pacmpl2019,
  author =       {Florence, Spencer P. and You, Shu-Hung and Tov, Jesse A. and
                  Findler, Robert Bruce},
  title =        {A Calculus for Esterel: If Can, Can. If No Can, No Can.},
  year =         {2019},
  issue_date =   {January 2019},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {3},
  number =       {POPL},
  url =          {https://doi.org/10.1145/3290374},
  doi =          {10.1145/3290374},
  journal =      {Proc. ACM Program. Lang.},
  month =        jan,
  articleno =    {Article 61},
  numpages =     {29},
  keywords =     {Synchronous Reactive Programming, Esterel, Semantics}
}
  
@article{felleisen-hieb:tcs1992,
  title =        "The revised report on the syntactic theories of sequential control
                  and state",
  journal =      "Theoretical Computer Science",
  volume =       "103",
  number =       "2",
  pages =        "235 - 271",
  year =         "1992",
  issn =         "0304-3975",
  doi =          "https://doi.org/10.1016/0304-3975(92)90014-7",
  url =          "http://www.sciencedirect.com/science/article/pii/0304397592900147",
  author =       "Matthias Felleisen and Robert Hieb",
  abstract =     "The syntactic theories of control and state are conservative
                  extensions of the λυ-calculus for equational reasoning about
                  imperative programming facilities in higher-order languages. Unlike
                  the simple λυ-calculus, the extended theories are mixtures of
                  equivalence relations and compatible congruence relations on the
                  term language, which significantly complicates the reasoning
                  process. In this paper we develop fully compatible equational
                  theories of the same imperative higher-order programming
                  languages. The new theories subsume the original calculi of control
                  and state and satisfy the usual Church–Rosser and Standardization
                  Theorems. With the new calculi, equational reasoning about
                  imperative programs becomes as simple as reasoning about functional
                  programs."
}

@inproceedings{kcofi:criswell:oakland2014,
  author =       {Criswell, John and Dautenhahn, Nathan and Adve, Vikram},
  title =        {KCoFI: Complete Control-Flow Integrity for Commodity Operating
                  System Kernels},
  year =         {2014},
  isbn =         {9781479946860},
  publisher =    {IEEE Computer Society},
  address =      {USA},
  url =          {https://doi.org/10.1109/SP.2014.26},
  doi =          {10.1109/SP.2014.26},
  booktitle =    {Proceedings of the 2014 IEEE Symposium on Security and Privacy},
  pages =        {292–307},
  numpages =     {16},
  keywords =     {control-flow integrity, operating systems, Free BSD, compiler,
                  formal verification},
  series =       {SP ’14}
}
  
@INPROCEEDINGS{spectre:kocher:oakland2019,
  author =       {P. {Kocher} and J. {Horn} and A. {Fogh} and D. {Genkin} and
                  D. {Gruss} and W. {Haas} and M. {Hamburg} and M. {Lipp} and
                  S. {Mangard} and T. {Prescher} and M. {Schwarz} and Y. {Yarom}},
  booktitle =    {2019 IEEE Symposium on Security and Privacy (SP)},
  title =        {Spectre Attacks: Exploiting Speculative Execution},
  year =         {2019},
  volume =       {},
  number =       {},
  pages =        {1-19},
  abstract =     {Modern processors use branch prediction and speculative execution
                  to maximize performance. For example, if the destination of a
                  branch depends on a memory value that is in the process of being
                  read, CPUs will try to guess the destination and attempt to execute
                  ahead. When the memory value finally arrives, the CPU either
                  discards or commits the speculative computation. Speculative logic
                  is unfaithful in how it executes, can access the victim's memory
                  and registers, and can perform operations with measurable side
                  effects. Spectre attacks involve inducing a victim to speculatively
                  perform operations that would not occur during correct program
                  execution and which leak the victim's confidential information via
                  a side channel to the adversary. This paper describes practical
                  attacks that combine methodology from side channel attacks, fault
                  attacks, and return-oriented programming that can read arbitrary
                  memory from the victim's process. More broadly, the paper shows
                  that speculative execution implementations violate the security
                  assumptions underpinning numerous software security mechanisms,
                  including operating system process separation, containerization,
                  just-in-time (JIT) compilation, and countermeasures to cache timing
                  and side-channel attacks. These attacks represent a serious threat
                  to actual systems since vulnerable speculative execution
                  capabilities are found in microprocessors from Intel, AMD, and ARM
                  that are used in billions of devices. While makeshift
                  processor-specific countermeasures are possible in some cases,
                  sound solutions will require fixes to processor designs as well as
                  updates to instruction set architectures (ISAs) to give hardware
                  architects and software developers a common understanding as to
                  what computation state CPU implementations are (and are not)
                  permitted to leak.},
  keywords =     {cache storage;computer architecture;computer
                  crime;cryptography;instruction sets;microprocessor chips;parallel
                  programming;program compilers;spectre attacks;branch
                  prediction;memory value;speculative computation;speculative
                  logic;side channel attacks;fault attacks;arbitrary
                  memory;speculative execution implementations;system process
                  separation;side-channel attacks;vulnerable speculative execution
                  capabilities;makeshift processor-specific
                  countermeasures;computation state CPU implementations;program
                  execution;software security mechanisms;Program
                  processors;Microarchitecture;Registers;Arrays;Transient
                  analysis;Hardware;Side-channel
                  attacks;Spectre;speculative-execution;microarchitecture-security;microarchitectural-attack},
  doi =          {10.1109/SP.2019.00002},
  ISSN =         {1081-6011},
  month =        {May},
}
@inproceedings{lipp:usenixsec2018,
  author =       {Moritz Lipp and Michael Schwarz and Daniel Gruss and Thomas
                  Prescher and Werner Haas and Anders Fogh and Jann Horn and Stefan
                  Mangard and Paul Kocher and Daniel Genkin and Yuval Yarom and Mike
                  Hamburg},
  title =        {Meltdown: Reading Kernel Memory from User Space},
  booktitle =    {27th {USENIX} Security Symposium ({USENIX} Security 18)},
  year =         {2018},
  isbn =         {978-1-939133-04-5},
  address =      {Baltimore, MD},
  pages =        {973--990},
  url =
                  {https://www.usenix.org/conference/usenixsecurity18/presentation/lipp},
  publisher =    {{USENIX} Association},
  month =        aug,
}
@article{costan:iacr2016,
  title =        {Intel SGX Explained},
  author =       {Victor Costan and Srinivas Devadas},
  journal =      {IACR Cryptology ePrint Archive},
  year =         {2016},
  pages =        {86}
}
@article{agner:copenhagen2012,
  title =        {The microarchitecture of Intel, AMD and VIA CPUs: An optimization
                  guide for assembly programmers and compiler makers},
  author =       {Fog, Agner},
  journal =      {Copenhagen University College of Engineering},
  pages =        {02--29},
  year =         {2012}
}
@article{coatcheck:lustig:sigplannot2016,
  author =       {Lustig, Daniel and Sethi, Geet and Martonosi, Margaret and
                  Bhattacharjee, Abhishek},
  title =        {COATCheck: Verifying Memory Ordering at the Hardware-OS Interface},
  year =         {2016},
  issue_date =   {June 2016},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {51},
  number =       {4},
  issn =         {0362-1340},
  url =          {https://doi.org/10.1145/2954679.2872399},
  doi =          {10.1145/2954679.2872399},
  journal =      {SIGPLAN Not.},
  month =        mar,
  pages =        {233–247},
  numpages =     {15},
  keywords =     {computer architecture, memory consistency models, address
                  translation, verification, virtual memory}
}
  
@INPROCEEDINGS{pipecheck:lustig:oakland2014,
  author =       {D. {Lustig} and M. {Pellauer} and M. {Martonosi}},
  booktitle =    {2014 47th Annual IEEE/ACM International Symposium on
                  Microarchitecture},
  title =        {PipeCheck: Specifying and Verifying Microarchitectural Enforcement
                  of Memory Consistency Models},
  year =         {2014},
  volume =       {},
  number =       {},
  pages =        {635-646},
  abstract =     {We present PipeCheck, a methodology and automated tool for
                  verifying that a particular micro architecture correctly implements
                  the consistency model required by its architectural
                  specification. PipeCheck adapts the notion of a "happens before"
                  graph from architecture-level analysis techniques to the micro
                  architecture space. Each node in the "micro architecturally happens
                  before" (μhb) graph represents not only a memory instruction, but
                  also a particular location (e.g., Pipeline stage) within the micro
                  architecture. Architectural specifications such as "preserved
                  program order" are then treated as propositions to be verified,
                  rather than simply as assumptions. PipeCheck allows an architect to
                  easily and rigorously test whether a micro architecture is stronger
                  than, equal in strength to, or weaker than its
                  architecturally-specified consistency model. We also specify and
                  analyze the behavior of common micro architectural optimizations
                  such as speculative load reordering which technically violate
                  formal architecture-level definitions. We evaluate PipeCheck using
                  a library of established litmus tests on a set of open-source
                  pipelines. Using PipeCheck, we were able to validate the largest
                  pipeline, the Open SPARC T2, in just minutes. We also identified a
                  bug in the O3 pipeline of the gem5 simulator.},
  keywords =     {formal specification;multiprocessing systems;pipeline
                  processing;program verification;software
                  architecture;PipeCheck;microarchitectural enforcement
                  verification;microarchitectural enforcement specification;memory
                  consistency models;architectural specification;architecture-level
                  analysis techniques;microarchitecture
                  space;microarchitecturally-happens-before graph;μhb graph;memory
                  instruction;memory location;pipeline stage;preserved-program
                  order;architecturally-specified consistency
                  model;microarchitectural optimizations;speculative load
                  reordering;formal architecture-level definitions;open-source
                  pipelines;OpenSPARC T2;O3 pipeline;gem5
                  simulator;Microarchitecture;Pipelines;Load modeling;Program
                  processors;Radio frequency;Buffer storage;Mathematical model},
  doi =          {10.1145/2954679.2872399},
  ISSN =         {2379-3155},
  month =        {Dec},
}
@article{thomadakis:jfe2011,
  author =       {Thomadakis, Michael},
  year =         {2011},
  month =        {03},
  pages =        {},
  title =        {The Architecture of the Nehalem Processor and Nehalem-EP SMP
                  Platforms},
  journal =      {JFE Technical Report}
}

@INPROCEEDINGS{arvind:iccad2004,
  author =       { {Arvind} and R. S. {Nikhil} and D. L. {Rosenband} and N. {Dave}},
  booktitle =    {IEEE/ACM International Conference on Computer Aided Design,
                  2004. ICCAD-2004.},
  title =        {High-level synthesis: an essential ingredient for designing complex
                  ASICs},
  year =         {2004},
  volume =       {},
  number =       {},
  pages =        {775-782},
  abstract =     {It is common wisdom that synthesizing hardware from higher-level
                  descriptions than Verilog incurs a performance penalty. The case
                  study here shows that this need not be the case. If the
                  higher-level language has suitable semantics, it is possible to
                  synthesize hardware that is competitive with hand-written Verilog
                  RTL. Differences in the hardware quality are dominated by
                  architecture differences and, therefore, it is more important to
                  explore multiple hardware architectures. This exploration is not
                  practical without quality synthesis from higher-level languages.},
  keywords =     {application specific integrated circuits;integrated circuit
                  design;high level synthesis;high level languages;hardware
                  description languages;high-level synthesis;ASIC;hardware
                  synthesis;Verilog RTL;hardware quality;hardware
                  architectures;quality synthesis;high level languages;High level
                  synthesis;Application specific integrated circuits;Hardware design
                  languages;Microarchitecture;Clocks;CMOS technology;Design
                  methodology;Software libraries;Testing;Costs},
  doi =          {10.1109/ICCAD.2004.1382681},
  ISSN =         {1092-3152},
  month =        {Nov},
}

@ARTICLE{arvind:micro1999,
  author =       { {Arvind} and X. {Shen}},
  journal =      {IEEE Micro},
  title =        {Using term rewriting systems to design and verify processors},
  year =         {1999},
  volume =       {19},
  number =       {3},
  pages =        {36-46},
  abstract =     {Term rewriting systems (TRSs) offer a convenient way to describe
                  parallel and asynchronous systems and prove an implementation's
                  correctness with respect to a specification. TRS descriptions,
                  augmented with proper information about the system building blocks,
                  also hold the promise of high-level synthesis. High-level
                  architectural descriptions that are both automatically
                  synthesizable and verifiable would permit architectural exploration
                  at a fraction of the time and cost required by current commercial
                  tools. In this article, we use TRSs to describe a speculative
                  processor capable of register renaming and out-of-order
                  execution. We lack space to discuss a synthesis procedure from TRSs
                  or to provide the details needed to make automatic synthesis
                  feasible; Nevertheless, we show that our speculative processor
                  produces the same set of behaviors as a simple nonpipelined
                  implementation. Our descriptions of microarchitectures are more
                  precise than those found in modern textbooks. The clarity of these
                  descriptions lets us study the impact of features such as write
                  buffers or caches, especially in multiprocessor systems.},
  keywords =     {rewriting systems;reduced instruction set computing;high level
                  synthesis;term rewriting systems;processors verification;high-level
                  synthesis;speculative processor;register renaming;write
                  buffers;multiprocessor systems;computer architectures;Process
                  design;Registers;Microarchitecture;Microprocessors;Computer
                  architecture;Reduced instruction set computing;Arithmetic;High
                  level synthesis;Costs;Formal verification},
  doi =          {10.1109/40.768501},
  ISSN =         {1937-4143},
  month =        {May},
}
@ARTICLE{hartbleed:de:tvlsi2020,
  author =       {A. {De} and M. N. I. {Khan} and K. {Nagarajan} and S. {Ghosh}},
  journal =      {IEEE Transactions on Very Large Scale Integration (VLSI) Systems},
  title =        {HarTBleed: Using Hardware Trojans for Data Leakage Exploits},
  year =         {2020},
  volume =       {},
  number =       {},
  pages =        {1-12},
  abstract =     {Data and information leakage is an important security concern in
                  current systems. Several data leakage prevention (DLP) techniques
                  have been proposed in the literature to prevent external as well as
                  internal data leakage. Most of these solutions try to trace data
                  flow and perform privilege checks to ensure the security of the
                  data at the software and system level. Architecture level leakage
                  vulnerabilities such as Spectre and Meltdown can be mitigated by
                  performance-expensive software patches or by modifying the
                  architecture itself. However, these solutions assume that the
                  underlying hardware platform is secure and free from tampering. In
                  this article, we present HarTBleed, a class of system attacks
                  involving hardware compromised with a Trojan embedded in the
                  CPU. We show that attacks crafted specifically to make use of the
                  Trojan can be used to obtain sensitive information from the address
                  space of a process. We propose the use of a capacitor-based Trojan
                  trigger that exploits the virtual addressing of L1 cache to
                  activate a Trojan payload that resets a target translation
                  lookaside buffer (TLB) entry to maliciously map to sensitive data
                  in memory. Extensive circuit simulation indicates that the proposed
                  Trojan trigger is not activated during test or normal operation
                  even under a wide range of process/temperature
                  conditions. Therefore, it remains undetected. A successful
                  HarTBleed-based exploit is demonstrated using an attack code by
                  modeling the Trojan effects in the GEM5 simulator.},
  keywords =     {Data leakage;hardware Trojan;translation lookaside buffer
                  (TLB);trigger},
  doi =          {10.1109/TVLSI.2019.2961358},
  ISSN =         {1557-9999},
  month =        {},
}
@INPROCEEDINGS{mahajan:memocode2007,
  author =       {Y. {Mahajan} and C. {Chan} and A. {Bayazit} and S. {Malik} and
                  W. {Qin}},
  booktitle =    {2007 5th IEEE/ACM International Conference on Formal Methods and
                  Models for Codesign (MEMOCODE 2007)},
  title =        {Verification Driven Formal Architecture and Microarchitecture
                  Modeling},
  year =         {2007},
  volume =       {},
  number =       {},
  pages =        {123-132},
  abstract =     {Our ability to verify complex hardware lags far behind our capacity
                  to design and fabricate it. We argue that this gap is partly due to
                  the limitations of RTL models when used for verification. Higher
                  level models such as SystemC and SystemVerilog aim to raise the
                  level of abstraction to enhance designer productivity; however,
                  they largely provide for executable but not analyzable
                  descriptions. We propose the use of formally analyzable design
                  models at two distinct levels above RTL: the architecture and the
                  microarchitecture level. At both these levels, we describe
                  concurrent units of data computation termed transactions. The
                  architecture level describes the computation/state updates in the
                  transactions and their interaction through shared data. The
                  microarchitecture level adds to this the resource usage in the
                  transactions as well as their interaction based on shared
                  resources. We then illustrate the applicability of these models in
                  a top-down verification methodology which addresses several
                  concerns of current methodologies.},
  keywords =     {formal verification;verification driven formal
                  architecture;microarchitecture modeling;RTL
                  models;SystemC;SystemVerilog;Microarchitecture;Concurrent
                  computing;Formal verification;State-space
                  methods;Productivity;Computer architecture;Algorithm design and
                  analysis;Emulation;Hardware design languages;Timing},
  doi =          {10.1109/MEMCOD.2007.371235},
  ISSN =         {null},
  month =        {May},
}
@article{secverilog:zhang:sigplannot2015,
  author =       {Zhang, Danfeng and Wang, Yao and Suh, G. Edward and Myers, Andrew
                  C.},
  title =        {A Hardware Design Language for Timing-Sensitive Information-Flow
                  Security},
  year =         {2015},
  issue_date =   {May 2015},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {50},
  number =       {4},
  issn =         {0362-1340},
  url =          {https://doi.org/10.1145/2775054.2694372},
  doi =          {10.1145/2775054.2694372},
  journal =      {SIGPLAN Not.},
  month =        mar,
  pages =        {503–516},
  numpages =     {14},
  keywords =     {timing channels, information flow control, hardware description
                  language, dependent types}
}
@INPROCEEDINGS{banga:vlsid2009,
  author =       {M. {Banga} and M. S. {Hsiao}},
  booktitle =    {2009 22nd International Conference on VLSI Design},
  title =        {A Novel Sustained Vector Technique for the Detection of Hardware
                  Trojans},
  year =         {2009},
  volume =       {},
  number =       {},
  pages =        {327-332},
  abstract =     {Intentional tampering in the internal circuit structure by
                  implanting Trojans can result in disastrous operational
                  consequences. While a faulty manufacturing leads to a nonfunctional
                  device, effect of an external implant can be far more
                  detrimental. Therefore, effective detection and diagnosis of such
                  maligned ICs in the post silicon testing phase is imperative, if
                  the parts are intended to be used in mission critical
                  applications. We propose a novel sustained vector methodology that
                  proves to be very effective in detecting the presence of a Trojan
                  in an IC. Each vector is repeated multiple times at the input of
                  both the genuine and the Trojan circuits that ensures the reduction
                  of extraneous toggles within the genuine circuit. Regions showing
                  wide variations in the power behavior are analyzed to isolate the
                  infected gate(s). Experimental results on ISCAS benchmark circuits
                  show that this approach can magnify the behavioral difference
                  between a genuine and infected IC up to thirty times as compared to
                  the previous approaches.},
  keywords =     {integrated circuit manufacture;invasive software;monolithic
                  integrated circuits;semiconductor industry;silicon;hardware Trojan
                  detection;internal circuit structure;external implant;maligned
                  IC;post silicon testing phase;sustained vector methodology;Trojan
                  circuits;gate infection;Hardware;Circuit
                  testing;Manufacturing;Automatic testing;Circuit
                  faults;Silicon;Costs;Fabrication;Viruses (medical);Built-in
                  self-test;Torjan;Side-channel analysis;Power profile},
  doi =          {10.1109/VLSI.Design.2009.22},
  ISSN =         {2380-6923},
  month =        {Jan},
}
@INPROCEEDINGS{wang:host2008,
  author =       { {Xiaoxiao Wang} and M. {Tehranipoor} and J. {Plusquellic}},
  booktitle =    {2008 IEEE International Workshop on Hardware-Oriented Security and
                  Trust},
  title =        {Detecting malicious inclusions in secure hardware: Challenges and
                  solutions},
  year =         {2008},
  volume =       {},
  number =       {},
  pages =        {15-19},
  abstract =     {This paper addresses a new threat to the security of integrated
                  circuits (ICs) used in safety critical, security and military
                  systems. The migration of IC fabrication to low-cost foundries has
                  made ICs vulnerable to malicious alterations, that could, under
                  specific conditions, result in functional changes and/or
                  catastrophic failure of the system in which they are embedded. We
                  refer to such malicious alternations and inclusions as Hardware
                  Trojans. The modification(s) introduced by the Trojan depends on
                  the application, with some designed to disable the system or
                  degrade signal integrity, while others are designed to defeat
                  hardware security and encryption to leak plain text
                  information. This paper explores the wide range of malicious
                  alternations of ICs that are possible and proposes a general
                  framework for their classification. The taxonomy is essential for
                  properly evaluating the effectiveness of methods designed to detect
                  Trojans. The latter portion of the paper explores several Trojan
                  detection strategies and the classes of Trojans each is most likely
                  to detect.},
  keywords =     {integrated circuit reliability;microprocessor chips;security of
                  data;malicious inclusions detecting;secure hardware;integrated
                  circuits security;IC fabrication;low-cost foundries;malicious
                  alterations;functional changes;catastrophic failure;hardware
                  Trojans;Hardware;Signal
                  design;Safety;Fabrication;Foundries;Degradation;Information
                  security;Cryptography;Taxonomy;Design methodology},
  doi =          {10.1109/HST.2008.4559039},
  ISSN =         {null},
  month =        {June},
}
@inproceedings{mero:chakraborty:ches2009,
  Author =       {Chakraborty, Rajat Subhra and Wolff, Francis and Paul, Somnath and
                  Papachristou, Christos and Bhunia, Swarup},
  title =        {MERO: A Statistical Approach for Hardware Trojan Detection},
  year =         {2009},
  isbn =         {9783642041372},
  publisher =    {Springer-Verlag},
  address =      {Berlin, Heidelberg},
  url =          {https://doi.org/10.1007/978-3-642-04138-9_28},
  doi =          {10.1007/978-3-642-04138-9_28},
  booktitle =    {Proceedings of the 11th International Workshop on Cryptographic
                  Hardware and Embedded Systems},
  pages =        {396–410},
  numpages =     {15},
  location =     {Lausanne, Switzerland},
  series =       {CHES ’09}
}
@article{guardcom:dijkstra:commacm1975,
  author =       {Dijkstra, Edsger W.},
  title =        {Guarded Commands, Nondeterminacy and Formal Derivation of Programs},
  year =         {1975},
  issue_date =   {August 1975},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {18},
  number =       {8},
  issn =         {0001-0782},
  url =          {https://doi.org/10.1145/360933.360975},
  doi =          {10.1145/360933.360975},
  journal =      {Commun. ACM},
  month =        aug,
  pages =        {453–457},
  numpages =     {5},
  keywords =     {termination, programming methodology, sequencing primitives,
                  nondeterminancy, programming languages, correctness proof,
                  repetition, programming language semantics, case-construction,
                  derivation of programs, program semantics}
}
@article{wirth:commacm1971,
  author =       {Wirth, Niklaus},
  title =        {Program Development by Stepwise Refinement},
  year =         {1971},
  issue_date =   {April 1971},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {14},
  number =       {4},
  issn =         {0001-0782},
  url =          {https://doi.org/10.1145/362575.362577},
  doi =          {10.1145/362575.362577},
  journal =      {Commun. ACM},
  month =        apr,
  pages =        {221–227},
  numpages =     {7},
  keywords =     {stepwise program construction, education in programming,
                  programming techniques}
}
@Article{back:actainf1988,
  author =       {Back, R. J. R.},
  title =        {A calculus of refinements for program derivations},
  journal =      {Acta Informatica},
  year =         {1988},
  volume =       {25},
  number =       {6},
  pages =        {593-624},
  abstract =     {A calculus of program refinements is described, to be used as a
                  tool for the step-by-step derivation of correct programs. A
                  derivation step is considered correct if the new program preserves
                  the total correctness of the old program. This requirement is
                  expressed as a relation of (correct) refinement between
                  nondeterministic program statements. The properties of this
                  relation are studied in detail. The usual sequential statement
                  constructors are shown to be monotone with respect to this relation
                  and it is shown how refinement between statements can be reduced to
                  a proof of total correctness of the refining statement. A special
                  emphasis is put on the correctness of replacement steps, where some
                  component of a program is replaced by another component. A method
                  by which assertions can be added to statements to justify
                  replacements in specific contexts is developed. The paper extends
                  the weakest precondition technique of Dijkstra to proving
                  correctness of larger program derivation steps, thus providing a
                  unified framework for the axiomatic, the stepwise refinement and
                  the transformational approach to program construction and
                  verification.},
  issn =         {1432-0525},
  doi =          {10.1007/BF00291051},
  url =          {https://doi.org/10.1007/BF00291051}
}

@book{dijkstra:phec1976,
  title =        {A discipline of programming},
  author =       {Dijkstra, Edsger Wybe and Dijkstra, Edsger Wybe and Dijkstra,
                  Edsger Wybe and Informaticien, Etats-Unis and Dijkstra, Edsger
                  Wybe},
  volume =       {1},
  year =         {1976},
  publisher =    {prentice-hall Englewood Cliffs}
}

@INPROCEEDINGS{hassan:acs2009,
  author =       {A. A. {Hassan} and W. M. {Bahgat}},
  booktitle =    {2009 IEEE/ACS International Conference on Computer Systems and
                  Applications},
  title =        {A framework for translating a high level security policy into low
                  level security mechanisms},
  year =         {2009},
  volume =       {},
  number =       {},
  pages =        {504-511},
  abstract =     {Security policies have different components; firewall, active
                  directory, and IDS are some examples of these
                  components. Enforcement of network security policies to low level
                  security mechanisms faces some essential difficulties. Consistency,
                  verification, and maintenance are the major ones of these
                  difficulties. One approach to overcome these difficulties is to
                  automate the process of translation of high level security policy
                  into low level security mechanisms. This paper introduces a
                  framework of an automation process that translates a high level
                  security policy into low level security mechanisms. The framework
                  is described in terms of three phases; in the first phase all
                  network assets are categorized according to their roles in the
                  network security and relations between them are identified to
                  constitute the network security model. This proposed model extends
                  the organization based access control (OrBAC) model to include not
                  only access control policy but also some other administrative
                  security policies like auditing policy. Besides, it enables
                  matching of each rule of the high level security policy with the
                  corresponding ones of the low level security policy. Through the
                  second phase, the high level security policy is mapped into the
                  network security model. The second phase could be considered as a
                  translation of the high level security policy into an intermediate
                  model level. Finally, the intermediate model level is translated
                  automatically into low level security mechanism. The paper
                  illustrates the applicability of proposed approach through an
                  application example.},
  keywords =     {authorisation;computer network management;telecommunication
                  security;high level network security policy;firewall
                  management;active directory;intrusion detection
                  system;organization-based access control model;Access
                  control;Automation;Computer security;Intrusion detection;Computer
                  science;Informatics;Maintenance engineering;Resource
                  management;Specification languages;Network security;Security
                  modeling;Security policy;Security management;OrBAC model},
  doi =          {10.1109/AICCSA.2009.5069371},
  ISSN =         {2161-5330},
  month =        {May},
}
@inproceedings{freek:memocode2019,
  author =       {Verbeek, Freek and Bockenek, Joshua and Bharadwaj, Abhijith and
                  Ravindran, Binoy and Roessle, Ian},
  title =        {Establishing a Refinement Relation between Binaries and Abstract
                  Code},
  year =         {2019},
  isbn =         {9781450369978},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3359986.3361215},
  doi =          {10.1145/3359986.3361215},
  booktitle =    {Proceedings of the 17th ACM-IEEE International Conference on Formal
                  Methods and Models for System Design},
  articleno =    {Article 17},
  numpages =     {5},
  keywords =     {abstraction, formal verification, refinement, x86-64 assembly},
  location =     {La Jolla, California},
  series =       {MEMOCODE ’19}
}
  
@INPROCEEDINGS{a2:yang:oakland2016,
  author =       {K. {Yang} and M. {Hicks} and Q. {Dong} and T. {Austin} and
                  D. {Sylvester}},
  booktitle =    {2016 IEEE Symposium on Security and Privacy (SP)},
  title =        {A2: Analog Malicious Hardware},
  year =         {2016},
  volume =       {},
  number =       {},
  pages =        {18-37},
  abstract =     {While the move to smaller transistors has been a boon for
                  performance it has dramatically increased the cost to fabricate
                  chips using those smaller transistors. This forces the vast
                  majority of chip design companies to trust a third party -- often
                  overseas -- to fabricate their design. To guard against shipping
                  chips with errors (intentional or otherwise) chip design companies
                  rely on post-fabrication testing. Unfortunately, this type of
                  testing leaves the door open to malicious modifications since
                  attackers can craft attack triggers requiring a sequence of
                  unlikely events, which will never be encountered by even the most
                  diligent tester. In this paper, we show how a fabrication-time
                  attacker can leverage analog circuits to create a hardware attack
                  that is small (i.e., requires as little as one gate) and stealthy
                  (i.e., requires an unlikely trigger sequence before effecting a
                  chip's functionality). In the open spaces of an already placed and
                  routed design, we construct a circuit that uses capacitors to
                  siphon charge from nearby wires as they transition between digital
                  values. When the capacitors fully charge, they deploy an attack
                  that forces a victim flip-flop to a desired value. We weaponize
                  this attack into a remotely-controllable privilege escalation by
                  attaching the capacitor to a wire controllable and by selecting a
                  victim flip-flop that holds the privilege bit for our processor. We
                  implement this attack in an OR1200 processor and fabricate a
                  chip. Experimental results show that our attacks work, show that
                  our attacks elude activation by a diverse set of benchmarks, and
                  suggest that our attacks evade known defenses.},
  keywords =     {flip-flops;invasive software;microprocessor
                  chips;remotely-controllable privilege escalation;victim
                  flip-flop;OR1200 processor;Trojan;capacitor;hardware attack;analog
                  circuit;chip design;chip fabrication;analog malicious
                  hardware;Hardware;Capacitors;Trojan horses;Fabrication;Integrated
                  circuit modeling;Transistors;Wires;analog;attack;malicious
                  hardware;security;Trojan},
  doi =          {10.1109/SP.2016.10},
  ISSN =         {2375-1207},
  month =        {May},
}
@INPROCEEDINGS{logiccamo:cocchi:dac2014,
  author =       {R. P. {Cocchi} and J. P. {Baukus} and L. W. {Chow} and
                  B. J. {Wang}},
  booktitle =    {2014 51st ACM/EDAC/IEEE Design Automation Conference (DAC)},
  title =        {Circuit camouflage integration for hardware IP protection},
  year =         2014,
  pages =        {1-5},
  abstract =     {Circuit camouflage technologies can be integrated into standard
                  logic cell developments using traditional CAD tools. Camouflaged
                  logic cells are integrated into a typical design flow using
                  standard front end and back end models. Camouflaged logic cells
                  obfuscate a circuit's function by introducing subtle cell design
                  changes at the GDS level. The logic function of a camouflaged logic
                  cell is extremely difficult to determine through silicon imaging
                  analysis preventing netlist extraction, clones and
                  counterfeits. The application of circuit camouflage as part of a
                  customer's design flow can protect hardware IP from reverse
                  engineering. Camouflage fill techniques further inhibit Trojan
                  circuit insertion by completely filling the design with realistic
                  circuitry that does not affect the primary design function. All
                  unused silicon appears to be functional circuitry, so an attacker
                  cannot find space to insert a Trojan circuit. The integration of
                  circuit camouflage techniques is compatible with standard chip
                  design flows and EDA tools, and ICs using such techniques have been
                  successfully employed in high-attack commercial and government
                  segments. Protected under issued and pending patents.},
  keywords =     {invasive software;logic design;logic gates;reverse
                  engineering;circuit camouflage technologies;standard logic cell
                  developments;CAD tools;camouflaged logic cells;front end
                  models;back end models;cell design changes;GDS level;logic
                  function;silicon imaging analysis;netlist extraction;hardware
                  IP;reverse engineering;camouflage fill techniques;Trojan circuit
                  insertion;functional circuitry;chip design flows;EDA
                  tools;Libraries;Logic gates;Application specific integrated     circuits;Standards;Foundries;Layout;Metals;Security;Design;Camouflage;Obfuscation;Reverse
                  Engineering;Anti-Cloning;Anti-Counterfeit;Anti-Tamper;Anti-Trojan},
  doi =          {10.1145/2593069.2602554},
  ISSN =         {0738-100X},
  month =        {June},
}
@INPROCEEDINGS{paratrojan:kumar:fdtc2014,
  author =       {R. {Kumar} and P. {Jovanovic} and W. {Burleson} and I. {Polian}},
  booktitle =    {2014 Workshop on Fault Diagnosis and Tolerance in Cryptography},
  title =        {Parametric Trojans for Fault-Injection Attacks on Cryptographic
                  Hardware},
  year =         {2014},
  volume =       {},
  number =       {},
  pages =        {18-28},
  abstract =     {We propose two extremely stealthy hardware Trojans that facilitate
                  fault-injection attacks in cryptographic blocks. The Trojans are
                  carefully inserted to modify the electrical characteristics of
                  predetermined transistors in a circuit by altering parameters such
                  as doping concentration and do pant area. These Trojans are
                  activated with very low probability under the presence of a
                  slightly reduced supply voltage (0.001 for 20% Vdd reduction). We
                  demonstrate the effectiveness of the Trojans by utilizing them to
                  inject faults into an ASIC implementation of the recently
                  introduced lightweight cipher PRINCE. Full circuit-level simulation
                  followed by differential cryptanalysis demonstrate that the secret
                  key can be reconstructed after around 5 fault-injections.},
  keywords =     {application specific integrated circuits;cryptography;invasive
                  software;probability;parametric Trojans;fault-injection
                  attacks;cryptographic hardware;probability;ASIC
                  implementation;lightweight cipher PRINCE;full circuit-level
                  simulation;differential cryptanalysis;Trojan horses;Circuit
                  faults;Logic
                  gates;Inverters;Transistors;Testing;Cryptography;fault-based
                  cryptanalysis;fault injection;hardware Trojans},
  doi =          {10.1109/FDTC.2014.12},
  ISSN =         {null},
  month =        {Sep.},
}
@INPROCEEDINGS{entt:nagarajan:host2019,
  author =       {K. {Nagarajan} and M. N. I. {Khan} and S. {Ghosh}},
  booktitle =    {2019 IEEE International Symposium on Hardware Oriented Security and
                  Trust (HOST)},
  title =        {ENTT: A Family of Emerging NVM-based Trojan Triggers},
  year =         {2019},
  volume =       {},
  number =       {},
  pages =        {51-60},
  abstract =     {The following topics are dealt with: cryptography; invasive
                  software; logic design; fault diagnosis; reverse engineering;
                  integrated circuit design; system-on-chip; security of data; field
                  programmable gate arrays; security.},
  keywords =     {cryptography;fault diagnosis;invasive software;logic design;reverse
                  engineering;cryptography;invasive software;logic design;fault
                  diagnosis;reverse engineering;integrated circuit
                  design;system-on-chip;security of data;field programmable gate
                  arrays;security;Trojan horses;Resistance;Payloads;Trigger
                  circuits;Nonvolatile memory;Random access memory;Logic
                  gates;Trojan;Memory Trojan;Trojan Trigger;Payloads;Read
                  Failure;Write Failure},
  doi =          {10.1109/HST.2019.8740836},
  ISSN =         {null},
  month =        {May},
}
@ARTICLE{tehranipoor:dt2010,
  author =       {M. {Tehranipoor} and F. {Koushanfar}},
  journal =      {IEEE Design Test of Computers},
  title =        {A Survey of Hardware Trojan Taxonomy and Detection},
  year =         {2010},
  volume =       {27},
  number =       {1},
  pages =        {10-25},
  abstract =     {Editor's note:Today's integrated circuits are vulnerable to
                  hardware Trojans, which are malicious alterations to the circuit,
                  either during design or fabrication. This article presents a
                  classification of hardware Trojans and a survey of published
                  techniques for Trojan detection.},
  keywords =     {integrated circuits;invasive software;hardware Trojan
                  taxonomy;integrated circuits;Trojan
                  detection;Hardware;Taxonomy;Fabrication;Circuit testing;Circuit
                  faults;Process design;Semiconductor device
                  testing;Manufacturing;Integrated circuit modeling;Semiconductor
                  device manufacture;design and test;hardware
                  Trojans;ICs;security;Trojan taxonomy and detection},
  doi =          {10.1109/MDT.2010.7},
  ISSN =         {1558-1918},
  month =        {Jan},
}
@INPROCEEDINGS{hoque:vts2018,
  author =       {T. {Hoque} and X. {Wang} and A. {Basak} and R. {Karam} and
                  S. {Bhunia}},
  booktitle =    {2018 IEEE 36th VLSI Test Symposium (VTS)},
  title =        {Hardware Trojan attacks in embedded memory},
  year =         {2018},
  volume =       {},
  number =       {},
  pages =        {1-6},
  abstract =     {Embedded memory, typically implemented with Static Random Access
                  Memory (SRAM) technology, is an integral part of modern processors
                  and System-on-Chips (SoCs). The reliability and integrity of
                  embedded SRAM arrays are essential to ensure dependable and
                  trustworthy computing. In the past, significant research has been
                  conducted to develop automated test algorithms aimed at
                  comprehensively detecting SRAM faults. While such tests have
                  advanced our ability to detect manufacturing imperfection induced
                  faults, they cannot ensure detection of deliberately implemented
                  design modifications, also known as hardware Trojans, in an SRAM
                  array by untrusted entities in the design and fabrication
                  flow. Indeed, these attacks constitute an emerging concern, since
                  they can affect the integrity of fabricated ICs and cause severe
                  consequences in the field. While a growing body of research
                  addresses Trojan attacks in logic circuits, little to no research
                  has explored these attacks in embedded memory arrays. In this
                  paper, for the first time to our knowledge, we propose a new class
                  of hardware Trojans targeting embedded SRAM arrays. The Trojans are
                  designed to evade industry standard post-manufacturing memory tests
                  (e.g. March test) while enabling targeted data tampering after
                  deployment. We demonstrate various forms of Trojan circuits in SRAM
                  that cause diverse malicious effects and have diverse activation
                  conditions while incurring minimal overhead in power, performance,
                  and stability. Further, the proposed layouts preserve the SRAM cell
                  footprint and incur negligible silicon area overhead.},
  keywords =     {embedded systems;fault diagnosis;integrated circuit
                  design;integrated circuit reliability;integrated circuit
                  testing;logic circuits;logic design;logic testing;SRAM
                  chips;system-on-chip;hardware Trojans;SRAM array;embedded memory
                  arrays;embedded SRAM arrays;industry standard post-manufacturing
                  memory tests;Trojan circuits;SRAM cell footprint;hardware Trojan
                  attacks;Static Random Access Memory technology;automated test
                  algorithms;SRAM faults;Trojan attacks;Trojan horses;Random access
                  memory;Circuit faults;Testing;Integrated circuits;Arrays;Hardware},
  doi =          {10.1109/VTS.2018.8368630},
  ISSN =         {2375-1053},
  month =        {April},
}
@inproceedings{king:leet2008,
  author =       {King, Samuel T. and Tucek, Joseph and Cozzie, Anthony and Grier,
                  Chris and Jiang, Weihang and Zhou, Yuanyuan},
  title =        {Designing and Implementing Malicious Hardware},
  year =         {2008},
  publisher =    {USENIX Association},
  address =      {USA},
  booktitle =    {Proceedings of the 1st Usenix Workshop on Large-Scale Exploits and
                  Emergent Threats},
  articleno =    {Article 5},
  numpages =     {8},
  location =     {San Francisco, California},
  series =       {LEET’08}
}
  
@INPROCEEDINGS{agrawal:oakland2007,
  author =       {D. {Agrawal} and S. {Baktir} and D. {Karakoyunlu} and P. {Rohatgi}
                  and B. {Sunar}},
  booktitle =    {2007 IEEE Symposium on Security and Privacy (SP '07)},
  title =        {Trojan Detection using IC Fingerprinting},
  year =         {2007},
  volume =       {},
  number =       {},
  pages =        {296-310},
  abstract =     {Hardware manufacturers are increasingly outsourcing their IC
                  fabrication work overseas due to their much lower cost
                  structure. This poses a significant security risk for ICs used for
                  critical military and business applications. Attackers can exploit
                  this loss of control to substitute Trojan ICs for genuine ones or
                  insert a Trojan circuit into the design or mask used for
                  fabrication. We show that a technique borrowed from side-channel
                  cryptanalysis can be used to mitigate this problem. Our approach
                  uses noise modeling to construct a set of fingerprints/or an IC
                  family utilizing side- channel information such as power,
                  temperature, and electromagnetic (EM) profiles. The set of
                  fingerprints can be developed using a few ICs from a batch and only
                  these ICs would have to be invasively tested to ensure that they
                  were all authentic. The remaining ICs are verified using
                  statistical tests against the fingerprints. We describe the
                  theoretical framework and present preliminary experimental results
                  to show that this approach is viable by presenting results obtained
                  by using power simulations performed on representative circuits
                  with several different Trojan circuitry. These results show that
                  Trojans that are 3-4 orders of magnitude smaller than the main
                  circuit can be detected by signal processing techniques. While
                  scaling our technique to detect even smaller Trojans in complex ICs
                  with tens or hundreds of millions of transistors would require
                  certain modifications to the IC design process, our results provide
                  a starting point to address this important problem.},
  keywords =     {circuit analysis computing;cryptography;integrated circuit
                  manufacture;invasive software;Trojan detection;IC
                  fingerprinting;security risk;side-channel cryptanalysis;noise
                  modeling;side-channel information;power simulations;Fingerprint
                  recognition;Fabrication;Integrated circuit noise;Integrated circuit
                  modeling;Circuit
                  testing;Hardware;Manufacturing;Outsourcing;Costs;Security},
  doi =          {10.1109/SP.2007.36},
  ISSN =         {2375-1207},
  month =        {May},
}
@inproceedings{SGX,
  title = {Software Guard Extensions Programming Reference},
  booktitle = {Intel Corp.},
  year = {2014},
  month = Oct,
  url = {https://software.intel.com/sites/default/files/managed/0d/53/319433-022.pdf},
}
@inproceedings{sanctum:costan:usenixsec,
  author =       {Victor Costan and Ilia Lebedev and Srinivas Devadas},
  title =        {Sanctum: Minimal Hardware Extensions for Strong Software Isolation},
  booktitle =    {25th {USENIX} Security Symposium ({USENIX} Security 16)},
  year =         {2016},
  isbn =         {978-1-931971-32-4},
  address =      {Austin, TX},
  pages =        {857--874},
  url =
                  {https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/costan},
  publisher =    {{USENIX} Association},
  month =        aug,
}

@article{ghostrider:liu:sigplannot2015,
  author =       {Liu, Chang and Harris, Austin and Maas, Martin and Hicks, Michael
                  and Tiwari, Mohit and Shi, Elaine},
  title =        {GhostRider: A Hardware-Software System for Memory Trace Oblivious
                  Computation},
  year =         {2015},
  issue_date =   {May 2015},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {50},
  number =       {4},
  issn =         {0362-1340},
  url =          {https://doi.org/10.1145/2775054.2694385},
  doi =          {10.1145/2775054.2694385},
  journal =      {SIGPLAN Not.},
  month =        mar,
  pages =        {87–101},
  numpages =     {15},
  keywords =     {memory trace obliviousness, secure type system, oblivious ram}
}
  
@InProceedings{reveal:andraus:lpar2008,
  author =       "Andraus, Zaher S.  and Liffiton, Mark H.  and Sakallah, Karem A.",
  editor =       "Cervesato, Iliano and Veith, Helmut and Voronkov, Andrei",
  title =        "Reveal: A Formal Verification Tool for Verilog Designs",
  booktitle =    "Logic for Programming, Artificial Intelligence, and Reasoning",
  year =         "2008",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "343--352",
  abstract =     "We describe the Reveal formal functional verification system and
                  its application to four representative hardware test cases. Reveal
                  employs counterexample-guided abstraction refinement, or CEGAR, and
                  is suitable for verifying the complex control logic of designs with
                  wide datapaths. Reveal performs automatic datapath abstraction
                  yielding an approximation of the original design with a much
                  smaller state space. This approximation is subsequently used to
                  verify the correctness of control logic interactions. If the
                  approximation proves to be too coarse, it is automatically refined
                  based on the spurious counterexample it generates. Such refinement
                  can be viewed as a form of on-demand ``learning'' similar in spirit
                  to conflict-based learning in modern Boolean satisfiability
                  solvers. The abstraction/refinement process is iterated until the
                  design is shown to be correct or an actual design error is
                  reported. The Reveal system allows some user control over the
                  abstraction and refinement steps. This paper examines the effect on
                  Reveal's performance of the various available options for
                  abstraction and refinement. Based on our initial experience with
                  this system, we believe that automating the verification for a
                  useful class of hardware designs is now quite feasible.",
  isbn =         "978-3-540-89439-1"
}

@InProceedings{uclid:bryant:cav2002,
  author =       "Bryant, Randal E.  and Lahiri, Shuvendu K.  and Seshia, Sanjit A.",
  editor =       "Brinksma, Ed and Larsen, Kim Guldstrand",
  title =        "Modeling and Verifying Systems Using a Logic of Counter Arithmetic
                  with Lambda Expressions and Uninterpreted Functions",
  booktitle =    "Computer Aided Verification",
  year =         "2002",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "78--92",
  abstract =     "In this paper, we present the logic of Counter Arithmetic with
                  Lambda Expressions and Uninterpreted Functions (CLU). CLU
                  generalizes the logic of equality with uninterpreted functions
                  (EUF) with constrained lambda expressions, ordering, and successor
                  and predecessor functions. In addition to modeling pipelined
                  processors that EUF has proved useful for, CLU can be used to model
                  many infinite-state systems including those with infinite memories,
                  finite and infinite queues including lossy channels, and networks
                  of identical processes. Even with this richer expressive power, the
                  validity of a CLU formula can be efficiently decided by translating
                  it to a propositional formula, and then using Boolean methods to
                  check validity. We give theoretical and empirical evidence for the
                  efficiency of our decision procedure. We also describe verification
                  techniques that we have used on a variety of systems, including an
                  out-of-order execution unit and the load-store unit of an
                  industrial microprocessor.",
  isbn =         "978-3-540-45657-5"
}
  
@misc{defroute:trippel:arxiv2019,
  title =        {Defensive Routing: a Preventive Layout-Level Defense Against
                  Untrusted Foundries},
  author =       {Timothy Trippel and Kang G. Shin and Kevin B. Bush and Matthew
                  Hicks},
  year =         {2019},
  eprint =       {1906.08842},
  archivePrefix ={arXiv},
  primaryClass = {cs.CR}
}
@misc{icas:trippel:arxiv2019,
  title =        {An Extensible Framework for Quantifying the Coverage of Defenses
                  Against Untrusted Foundries},
  author =       {Timothy Trippel and Kang G. Shin and Kevin B. Bush and Matthew
                  Hicks},
  year =         {2019},
  eprint =       {1906.08836},
  archivePrefix ={arXiv},
  primaryClass = {cs.CR}
}

@INPROCEEDINGS{ba:isvlsi2016,
  author =       {P. {Ba} and S. {Dupuis} and M. {Palanichamy} and
                  {Marie-Lise-Flottes} and G. D. {Natale} and B. {Rouzeyre}},
  booktitle =    {2016 IEEE Computer Society Annual Symposium on VLSI (ISVLSI)},
  title =        {Hardware Trust through Layout Filling: A Hardware Trojan Prevention
                  Technique},
  year =         {2016},
  volume =       {},
  number =       {},
  pages =        {254-259},
  abstract =     {The insertion of malicious alterations to a circuit, referred to as
                  Hardware Trojans, is a threat considered more and more seriously
                  during the last years. Numerous methods have been proposed in the
                  literature to detect the presence of such alterations. More
                  recently, Design-for-Hardware-Trust (DfHT) methods have been
                  proposed, that enhance the design of the circuit in order to
                  incorporate features that can either prevent the insertion of a HT
                  or that can help detection methods. This paper focuses on a HT
                  prevention technique that aims at creating a layout without filler
                  cells, which are assumed to provide a great opportunity for HT
                  insertion, in order to make the insertion of a HT in a layout as
                  difficult as possible.},
  keywords =     {invasive software;layout filling;hardware Trojan prevention
                  technique;malicious alterations;design-for-hardware-trust
                  methods;DfHT methods;Logic gates;Layout;Routing;Integrated
                  circuits;Shift registers;Transistors;Logic
                  testing;Harware-Trojans;Design-for-Hardware-Trust;Layout;Placement
                  and routing},
  doi =          {10.1109/ISVLSI.2016.22},
  ISSN =         {2159-3477},
  month =        {July},
}
@INPROCEEDINGS{ba:ecctd2015,
  author =       {P. {Ba} and M. {Palanichamy} and S. {Dupuis} and M. {Flottes} and
                  G. {Di Natale} and B. {Rouzeyre}},
  booktitle =    {2015 European Conference on Circuit Theory and Design (ECCTD)},
  title =        {Hardware Trojan prevention using layout-level design approach},
  year =         {2015},
  volume =       {},
  number =       {},
  pages =        {1-4},
  abstract =     {Hardware Trojans (HTs) are ultimately a dangerous threat in
                  semiconductor industry. The serious impact of HTs in security
                  applications and global economy brings extreme importance to their
                  detection and prevention techniques. This paper focuses on
                  developing a HT prevention techniques through a layout level design
                  approach. The principle is to let no available space on silicon for
                  an attacker to insert a HT. Experiments determine the maximum
                  occupational rate and critical empty spaces while filling with
                  standard cells. The proposed technique makes HT insertion nearly
                  impossible.},
  keywords =     {invasive software;hardware Trojan prevention;layout-level design
                  approach;HT prevention techniques;security applications;global
                  economy;detection techniques;standard cells;maximum occupational
                  rate;critical empty spaces;Decision support systems;Trojan
                  horses;Europe;Circuit theory;Electronics
                  industry;Silicon;Filling;Hardware Trojans (HTs);HT
                  prevention;layout;occupation ratio;Design for Hardware trust},
  doi =          {10.1109/ECCTD.2015.7300093},
  ISSN =         {null},
  month =        {Aug},
}
@INPROCEEDINGS{bisa:xiao:host2013,
  author =       {K. {Xiao} and M. {Tehranipoor}},
  booktitle =    {2013 IEEE International Symposium on Hardware-Oriented Security and
                  Trust (HOST)},
  title =        {BISA: Built-in self-authentication for preventing hardware Trojan
                  insertion},
  year =         {2013},
  volume =       {},
  number =       {},
  pages =        {45-50},
  abstract =     {Hardware Trojans have become a significant threat to government
                  agencies and enterprises that require security and trustworthiness
                  in systems with critical applications. Detecting hardware Trojans
                  is very challenging because of the diversity of Trojans and
                  unpredictable process variations during fabrication. In this paper,
                  we propose a novel technique, called built-in self-authentication
                  (BISA), that can fill unused spaces in a circuit layout by
                  functional filler cells instead of non-functional filler cells. All
                  functional filler cells will be tested by BISA itself and a digital
                  signature would be generated. Any modification on BISA will result
                  in a different signature. Thus, BISA can be used to prevent Trojan
                  insertion or make Trojan insertion extremely difficult. BISA can be
                  applied to any single-module or bottom-up hierarchical design, and
                  we evaluate it on different circuits to demonstrate the effective
                  of this technique.},
  keywords =     {authorisation;built-in self test;digital signatures;integrated
                  circuit layout;invasive software;BISA;built-in
                  self-authentication;hardware Trojan insertion prevention;government
                  agencies;enterprises;security;circuit layout;nonfunctional filler
                  cells;digital signature;Trojan horses;Logic
                  gates;Standards;Layout;Capacitance;Routing;Hardware},
  doi =          {10.1109/HST.2013.6581564},
  ISSN =         {null},
  month =        {June},
}
@INPROCEEDINGS{jin:host2008,
  author =       { {Yier Jin} and Y. {Makris}},
  booktitle =    {2008 IEEE International Workshop on Hardware-Oriented Security and
                  Trust},
  title =        {Hardware Trojan detection using path delay fingerprint},
  year =         {2008},
  volume =       {},
  number =       {},
  pages =        {51-57},
  abstract =     {Trusted IC design is a recently emerged topic since fabrication
                  factories are moving worldwide in order to reduce cost. In order to
                  get a low-cost but effective hardware trojan detection method to
                  complement traditional testing methods, a new behavior-oriented
                  category method is proposed to divide trojans into two categories:
                  explicit payload trojan and implicit payload trojan. This
                  categorization method makes it possible to construct trojan models
                  and then lower the cost of testing. Path delays of nominal chips
                  are collected to construct a series of fingerprints, each one
                  representing one aspect of the total characteristics of a genuine
                  design. Chips are validated by comparing their delay parameters to
                  the fingerprints. The comparison of path delays makes small trojan
                  circuits significant from a delay point of view. The
                  experimentpsilas results show that the detection rate on explicit
                  payload trojans is 100\%, while this method should be developed
                  further if used to detect implicit payload trojans.},
  keywords =     {cryptography;integrated circuits;invasive software;hardware Trojan
                  detection;path delay fingerprint;trusted integrated circuit
                  design;Hardware;Delay;Fingerprint recognition;Circuit
                  testing;Costs;Payloads;Power system
                  modeling;Security;Fabrication;Production facilities},
  doi =          {10.1109/HST.2008.4559049},
  ISSN =         {null},
  month =        {June},
}
@INPROCEEDINGS{tesr:narasimhan:host2011,
  author =       {S. {Narasimhan} and X. {Wang} and D. {Du} and R. S. {Chakraborty}
                  and S. {Bhunia}},
  booktitle =    {2011 IEEE International Symposium on Hardware-Oriented Security and
                  Trust},
  title =        {TeSR: A robust Temporal Self-Referencing approach for Hardware
                  Trojan detection},
  year =         {2011},
  volume =       {},
  number =       {},
  pages =        {71-74},
  abstract =     {Malicious modification of integrated circuits, referred to as
                  Hardware Trojans, in untrusted fabrication facility has emerged as
                  a major security threat. Logic testing approaches are not very
                  effective for detecting large sequential Trojans which require
                  multiple state transitions often triggered by rare circuit events
                  in order to activate and cause malfunction. On the other hand,
                  side-channel analysis has emerged as an effective approach for
                  detection of such large sequential Trojans. However, existing
                  side-channel approaches suffer from large reduction in detection
                  sensitivity with increasing process variations or decreasing Trojan
                  size. In this paper, we propose TeSR, a Temporal Self-Referencing
                  approach that compares the current signature of a chip at two
                  different time windows to completely eliminate the effect of
                  process noise, thus providing high detection sensitivity for
                  Trojans of varying size. Furthermore, unlike existing approaches,
                  it does not require golden chip instances as a
                  reference. Simulation results for three complex designs and three
                  representative sequential Trojan circuits demonstrate the
                  effectiveness of the approach under large inter- and intra-die
                  process variations.},
  keywords =     {electronic engineering computing;integrated circuit
                  testing;invasive software;logic testing;TeSR;robust temporal
                  self-referencing approach;hardware Trojan detection;integrated
                  circuit malicious modification;side-channel analysis;Trojan
                  horses;Hardware;Noise;Integrated circuits;Current
                  measurement;Radiation detectors;Hardware Trojan;side-channel
                  analysis;self-referencing;Trust in IC},
  doi =          {10.1109/HST.2011.5954999},
  ISSN =         {null},
  month =        {June},
}

@INPROCEEDINGS{potkonjak:dac2009,
  author =       {M. {Potkonjak} and A. {Nahapetian} and M. {Nelson} and T. {Massey}},
  booktitle =    {2009 46th ACM/IEEE Design Automation Conference},
  title =        {Hardware Trojan horse detection using gate-level characterization},
  year =         {2009},
  volume =       {},
  number =       {},
  pages =        {688-693},
  abstract =     {Hardware Trojan horses (HTHs) are the malicious altering of
                  hardware specification or implementation in such a way that its
                  functionality is altered under a set of conditions defined by the
                  attacker. There are numerous HTHs sources including untrusted
                  foundries, synthesis tools and libraries, testing and verification
                  tools, and configuration scripts. HTH attacks can greatly comprise
                  security and privacy of hardware users either directly or through
                  interaction with pertinent systems and application software or with
                  data. However, while there has been a huge research and development
                  effort for detecting software Trojan horses, surprisingly, HTHs are
                  rarely addressed. HTH detection is a particularly difficult task in
                  modern and pending deep submicron technologies due to intrinsic
                  manufacturing variability. Our goal is to provide an impetus for
                  HTH research by creating a generic and easily applicable set of
                  techniques and tools for HTH detection. We start by introducing a
                  technique for recovery of characteristics of gates in terms of
                  leakage current, switching power, and delay, which utilizes linear
                  programming to solve a system of equations created using
                  nondestructive measurements of power or delays. This technique is
                  combined with constraint manipulation techniques to detect embedded
                  HTHs. The effectiveness of the approach is demonstrated on a number
                  of standard benchmarks.},
  keywords =     {integrated circuits;invasive software;linear programming;logic
                  gates;power aware computing;hardware Trojan horse detection;gate
                  level characterization;hardware specification;linear
                  programming;nondestructive power measurements;Hardware;Invasive
                  software;Foundries;Software libraries;Testing;Data security;Data
                  privacy;Application software;Research and
                  development;Manufacturing;Hardware Trojan horses;gate-level
                  characterization;linear programming;manufacturing variability},
  doi =          {10.1145/1629911.1630091},
  ISSN =         {0738-100X},
  month =        {July},
}

@article{quadir:etcs2016,
  author =       {Quadir, Shahed E. and Chen, Junlin and Forte, Domenic and
                  Asadizanjani, Navid and Shahbazmohamadi, Sina and Wang, Lei and
                  Chandy, John and Tehranipoor, Mark},
  title =        {A Survey on Chip to System Reverse Engineering},
  year =         {2016},
  issue_date =   {December 2016},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {13},
  number =       {1},
  issn =         {1550-4832},
  url =          {https://doi.org/10.1145/2755563},
  doi =          {10.1145/2755563},
  journal =      {J. Emerg. Technol. Comput. Syst.},
  month =        apr,
  articleno =    {Article 6},
  numpages =     {34},
  keywords =     {anti--reverse engineering (anti-RE), hardware security, delayering,
                  Reverse engineering (RE), FPGA security, firmware extraction}
}
  
@article{obsdet:mclean:jcs1992,
  author =       {McLean, John},
  title =        {Proving Noninterference and Functional Correctness Using Traces},
  year =         {1992},
  issue_date =   {January 1992},
  publisher =    {IOS Press},
  address =      {NLD},
  volume =       {1},
  number =       {1},
  issn =         {0926-227X},
  journal =      {J. Comput. Secur.},
  month =        jan,
  pages =        {37–57},
  numpages =     {21}
}
  
@inproceedings{roscoe:oakland1995,
  author =       {Roscoe, A. W.},
  title =        {CSP and Determinism in Security Modelling},
  year =         {1995},
  publisher =    {IEEE Computer Society},
  address =      {USA},
  booktitle =    {Proceedings of the 1995 IEEE Symposium on Security and Privacy},
  pages =        {114},
  numpages =     {1},
  keywords =     {confidentiality properties, input actions, algorithm theory,
                  efficient algorithm, abstraction mechanisms, deterministic
                  algorithms, determinism, abstracted low-security viewpoint,
                  security modelling, output action, security of data, CSP, model
                  checker},
  series =       {SP ’95}
}
  
@INPROCEEDINGS{mccullough:oakland1987,
  author =       {D. {McCullough}},
  booktitle =    {1987 IEEE Symposium on Security and Privacy},
  title =        {Specifications for Multi-Level Security and a Hook-Up},
  year =         {1987},
  volume =       {},
  number =       {},
  pages =        {161-161},
  abstract =     {In this paper, we give a brief description of several formalisms
                  for computer security, and discuss some of the problems in their
                  interpretation and application. We define the property of "hook-up
                  security", which can be shown to imply that a collection of hook-up
                  secure systems can be hooked up to form a secure complex system. We
                  believe this result addresses some of the problems with other
                  definitions of security, and will be valuable in the design of
                  large secure systems from simpler secure components.},
  keywords =     {Security;Interconnected systems;History;Protocols;Object oriented
                  modeling;Interference;Data models},
  doi =          {10.1109/SP.1987.10009},
  ISSN =         {1540-7993},
  month =        {April},
}

@inproceedings{specs:hicks:asplos2015,
  author =       {Hicks, Matthew and Sturton, Cynthia and King, Samuel T. and Smith,
                  Jonathan M.},
  title =        {SPECS: A Lightweight Runtime Mechanism for Protecting Software from
                  Security-Critical Processor Bugs},
  year =         2015,
  isbn =         9781450328357,
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/2694344.2694366},
  doi =          {10.1145/2694344.2694366},
  booktitle =    {Proceedings of the Twentieth International Conference on
                  Architectural Support for Programming Languages and Operating
                  Systems},
  pages =        {517–529},
  numpages =     13,
  keywords =     {processor errata, security-critical processor errata, hardware
                  security exploits},
  location =     {Istanbul, Turkey},
  series =       {ASPLOS ’15}
}

@INPROCEEDINGS{protogen:oswald:isca2018,
  author =       {N. {Oswald} and V. {Nagarajan} and D. J. {Sorin}},
  booktitle =    {2018 ACM/IEEE 45th Annual International Symposium on Computer
                  Architecture (ISCA)},
  title =        {ProtoGen: Automatically Generating Directory Cache Coherence
                  Protocols from Atomic Specifications},
  year =         {2018},
  volume =       {},
  number =       {},
  pages =        {247-260},
  abstract =     {Designing directory cache coherence protocols is complicated
                  because coherence transactions are not atomic in modern multicore
                  processors. A coherence transaction comprises multiple messages,
                  and these messages can interleave with other conflicting coherence
                  transactions initiated by other cores. To overcome this
                  architectural challenge, we present ProtoGen, an automated tool for
                  taking the description of a directory protocol with atomic
                  transactions (i.e., no concurrency) and generating the
                  corresponding protocol for a multicore with non-atomic
                  transactions. ProtoGen outputs the finite state machines for the
                  cache and directory controllers, including all of the transient
                  states that are possible with concurrent transactions. We have used
                  ProtoGen to generate complete MSI, MESI, and MOSI protocols given
                  their stable state protocol specifications. We have verified the
                  generated protocols for safety and deadlock freedom using the Murφ
                  model checker. Our generated protocols are identical to or better
                  than manually generated protocols, at times even discovering
                  opportunities to reduce stalling.},
  keywords =     {cache storage;concurrency control;finite state machines;formal
                  specification;formal verification;multiprocessing
                  systems;protocols;ProtoGen;atomic specifications;Murφ model
                  checker;MESI protocol;MOSI protocol;MSI protocol;cache
                  controllers;directory cache coherence protocols;multicore
                  processors;stable state protocol specifications;concurrent
                  transactions;directory controllers;finite state machines;nonatomic
                  transactions;atomic transactions;multiple messages;coherence
                  transaction;Protocols;Coherence;Transient
                  analysis;Hardware;Multicore processing;Concurrent
                  computing;Tools;cache coherence protocols;design
                  automation;hardware synthesis},
  doi =          {10.1109/ISCA.2018.00030},
  ISSN =         {2575-713X},
  month =        {June},
}

@InProceedings{kaiser:gruss:essos2017,
  author =       "Gruss, Daniel and Lipp, Moritz and Schwarz, Michael and Fellner,
                  Richard and Maurice, Cl{\'e}mentine and Mangard, Stefan",
  editor =       "Bodden, Eric and Payer, Mathias and Athanasopoulos, Elias",
  title =        "KASLR is Dead: Long Live KASLR",
  booktitle =    "Engineering Secure Software and Systems",
  year =         "2017",
  publisher =    "Springer International Publishing",
  address =      "Cham",
  pages =        "161--176",
  abstract =     "Modern operating system kernels employ address space layout
                  randomization (ASLR) to prevent control-flow hijacking attacks and
                  code-injection attacks. While kernel security relies fundamentally
                  on preventing access to address information, recent attacks have
                  shown that the hardware directly leaks this information. Strictly
                  splitting kernel space and user space has recently been proposed as
                  a theoretical concept to close these side channels. However, this
                  is not trivially possible due to architectural restrictions of the
                  x86 platform.",
  isbn =         "978-3-319-62105-0"
}
@misc{kpti:hansen:lkml2017,
  title = {{KPTI Patch}},
  author = {Dave Hansen},
  month = {December},
  year = 2017,
  howpublished = "\url{https://lkml.org/lkml/2017/12/18/1523}",
  note = "[Online; accessed 11-March-2019]",
}

@InProceedings{burchdill:cav1994,
  author =       "Burch, Jerry R.and Dill, David L.",
  editor =       "Dill, David L.",
  title =        "Automatic verification of pipelined microprocessor control",
  booktitle =    "Computer Aided Verification",
  year =         "1994",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "68--80",
  abstract =     "We describe a technique for verifying the control logic of
                  pipelined microprocessors. It handles more complicated designs, and
                  requires less human intervention, than existing methods. The
                  technique automatically compares a pipelined implementation to an
                  architectural description. The CPU time needed for verification is
                  independent of the data path width, the register file size, and the
                  number of ALU operations. Debugging information is automatically
                  produced for incorrect processor designs. Much of the power of the
                  method results from an efficient validity checker for a logic of
                  uninterpreted functions with equality. Empirical results include
                  the verification of a pipelined implementation of a subset of the
                  DLX architecture.",
  isbn =         "978-3-540-48469-1"
}
@article{amtoft-sas2004,
  title =        "A logic for information flow analysis with an application to
                  forward slicing of simple imperative programs",
  journal =      "Science of Computer Programming",
  volume =       "64",
  number =       "1",
  pages =        "3 - 28",
  year =         "2007",
  note =         "Special issue on the 11th Static Analysis Symposium - SAS 2004",
  issn =         "0167-6423",
  doi =          "https://doi.org/10.1016/j.scico.2006.03.002",
  url =          "http://www.sciencedirect.com/science/article/pii/S0167642306001559",
  author =       "Torben Amtoft and Anindya Banerjee",
  keywords =     "Abstract interpretation, Denotational semantics, Frame rule, Hoare
                  logic, Information flow analysis, Program slicing, Strongest
                  postcondition",
  abstract =     "We specify an information flow analysis for a simple imperative
                  language, using a Hoare-like logic. The logic facilitates static
                  checking of a larger class of programs than can be checked by
                  extant type-based approaches in which a program is deemed insecure
                  when it contains an insecure subprogram. The logic is based on an
                  abstract interpretation of a “prelude” semantics which makes
                  independence between program variables explicit. Unlike other, more
                  precise, approaches based on Hoare logics, our approach does not
                  require a theorem prover to generate invariants. We demonstrate the
                  modularity of our approach by showing that a frame rule holds in
                  our logic. Finally, we show how our logic can be applied to a
                  program transformation, namely, forward slicing: given a derivation
                  of a program in the logic, with the information that variable l is
                  independent of variable h, the slicing transformation
                  systematically creates the forward l-slice of the program: the
                  slice contains all the commands independent of h. We show that the
                  slicing transformation is semantics preserving."
}
@article{saabas-nwpt2006,
  title =        "Program and proof optimizations with type systems",
  journal =      "The Journal of Logic and Algebraic Programming",
  volume =       "77",
  number =       "1",
  pages =        "131 - 154",
  year =         "2008",
  note =         "The 16th Nordic Workshop on the Prgramming Theory (NWPT 2006)",
  issn =         "1567-8326",
  doi =          "https://doi.org/10.1016/j.jlap.2008.05.007",
  url =          "http://www.sciencedirect.com/science/article/pii/S1567832608000490",
  author =       "Ando Saabas and Tarmo Uustalu",
  keywords =     "Data-flow analyses, Optimizations, Type systems, Certification,
                  Proof optimization",
  abstract =     "We demonstrate a method for describing data-flow analyses based
                  program optimizations as compositional type systems with a
                  transformation component. Analysis results are presented in terms
                  of types ascribed to expressions and statements, certifiable by
                  type derivations, and the transformation component carries out the
                  optimizations that the type derivations license. We describe dead
                  code elimination and common subexpression elimination. In the case
                  of common subexpression elimination we circumvent
                  non-compositionality with a combined type system for a combination
                  of two analyses. The motivation of this work lies in certified code
                  applications, where an optimization of a program must be supported
                  by a checkable justification. As an example application we
                  highlight “proof optimization”, i.e., mechanical transformation of
                  a program’s functional correctness proof together with the program,
                  based on the analysis type derivation."
}
@article{barros-fac2012,
  author =       {Barros, Jos\'{e} Bernardo and Cruz, Daniela and Henriques, Pedro
                  Rangel and Pinto, Jorge Sousa},
  title =        {Assertion-Based Slicing and Slice Graphs},
  year =         {2012},
  issue_date =   {March 2012},
  publisher =    {Springer-Verlag},
  address =      {Berlin, Heidelberg},
  volume =       {24},
  number =       {2},
  issn =         {0934-5043},
  url =          {https://doi.org/10.1007/s00165-011-0196-1},
  doi =          {10.1007/s00165-011-0196-1},
  journal =      {Form. Asp. Comput.},
  month =        mar,
  pages =        {217–248},
  numpages =     {32},
  keywords =     {Control flow graphs, Verification conditions, Program analysis,
                  Program slicing}
}
  

@article{vasudevan-avocs2004,
  title =        "Efficient Model Checking of Hardware Using Conditioned Slicing",
  journal =      "Electronic Notes in Theoretical Computer Science",
  volume =       "128",
  number =       "6",
  pages =        "279 - 294",
  year =         "2005",
  note =         "Proceedings of the Fouth International Workshop on Automated
                  Verification of Critical Systems (AVoCS 2004)",
  issn =         "1571-0661",
  doi =          "https://doi.org/10.1016/j.entcs.2005.04.017",
  url =          "http://www.sciencedirect.com/science/article/pii/S1571066105002495",
  author =       "Shobha Vasudevan and E. Allen Emerson and Jacob A. Abraham",
  keywords =     "Hardware Verification, Program Slicing, Conditioned Slicing, LTL
                  property, Abstraction based Verification, Safety properties, Model
                  Checking, Hardware Description Languages",
  abstract =     "In this work, we present an abstraction based property verification
                  technique for hardware using conditioned slicing. We handle safety
                  property specifications of the form G(antecedent⇒consequent). We
                  use the antecedent of the properties to create our abstractions,
                  Antecedent Conditioned Slices. We extend conditioned slicing to
                  Hardware Description Languages (HDLs). We provide a theoretical
                  foundation for our conditioned slicing based verification
                  technique. We also present experimental results on the Verilog RTL
                  implementation of the USB 2.0. We demonstrate very high performance
                  gains achieved by our technique when compared to static program
                  slicing, using state-of-the-art model checkers."
}
@InProceedings{clarke-chdvm1999,
  author =       "Clarke, E. M.  and Fujita, M.  and Rajan, S. P.  and Reps, T.  and
                  Shankar, S.  and Teitelbaum, T.",
  editor =       "Pierre, Laurence and Kropf, Thomas",
  title =        "Program Slicing of Hardware Description Languages",
  booktitle =    "Correct Hardware Design and Verification Methods",
  year =         "1999",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "298--313",
  abstract =     "Hardware description languages (HDLs) are used today to describe
                  circuits at all levels. In large HDL programs, there is a need for
                  source code reduction techniques to address a myriad of problems in
                  formal verification, design, simulation, and testing. Program
                  slicing is a static program analysis technique that allows an
                  analyst to automatically extract portions of programs relevant to
                  the aspects being analyzed. We extend program slicing to HDLs, thus
                  allowing for automatic program reduction to allow the user to focus
                  on relevant code portions. We have implemented a VHDL slicing tool
                  composed of a general inter-procedural slicer and a front-end that
                  captures VHDL execution semantics. This paper provides an overview
                  of program slicing, a discussion of how to slice VHDL programs, a
                  description of the resulting tool, and a brief overview of some
                  applications and experimental results.",
  isbn =         "978-3-540-48153-9"
}

@INPROCEEDINGS{vasudevan-vlsid2007,
  author =       {S. {Vasudevan} and V. {Viswanath} and J. A. {Abraham}},
  booktitle =    {20th International Conference on VLSI Design held jointly with 6th
                  International Conference on Embedded Systems (VLSID'07)},
  title =        {Efficient Microprocessor Verification using Antecedent Conditioned
                  Slicing},
  year =         {2007},
  volume =       {},
  number =       {},
  pages =        {43-49},
  abstract =     {The authors present a technique for automatic verification of
                  pipelined microprocessors using model checking. Antecedent
                  conditioned slicing is an efficient abstraction technique for
                  hardware designs at the register transfer level (RTL). Antecedent
                  conditioned slicing prunes the verification state space, using
                  information from the antecedent of a given LTL property. In this
                  work, the authors model instructions of a pipelined processor as
                  LTL properties, such that the instruction opcode forms the
                  antecedent. The antecedent conditioned slicing to decompose the
                  problem space of pipelined processor verification on an
                  instruction-wise basis was used. We pass the resulting smaller,
                  tractable problems through a lower level verification engine. We
                  thereby verify that every instruction behaves according to the
                  specification and ensure that non-target registers are not modified
                  by the instruction. The SMV model checker to verify all the
                  instruction classes of a Verilog RTL implementation of the OR1200,
                  an off-the-shelf pipelined processor was used},
  keywords =     {formal verification;hardware description languages;logic
                  design;microprocessor chips;pipeline processing;microprocessor
                  verification;antecedent conditioned slicing;automatic
                  verification;pipelined microprocessors;model checking;abstraction
                  technique;register transfer level;verification state space;LTL
                  properties;pipelined processor verification;SMV model
                  checker;Verilog RTL
                  implementation;Microprocessors;Engines;Registers;Hardware design
                  languages;State-space methods;Formal verification;Process
                  design;Binary decision diagrams;Jacobian matrices;Testing},
  doi =          {10.1109/VLSID.2007.70},
  ISSN =         {2380-6923},
  month =        {Jan},
}

@Article{clarke-sttt2002,
  author =       {Clarke, E. M.  and Fujita, M.  and Rajan, S. P.  and Reps, T.  and
                  Shankar, S.  and Teitelbaum, T.},
  title =        {Program slicing for VHDL},
  journal =      {International Journal on Software Tools for Technology Transfer},
  year =         {2002},
  month =        {Oct},
  day =          {01},
  volume =       {4},
  number =       {1},
  pages =        {125-137},
  abstract =     {Hardware description languages (HDLs) are used today to describe
                  circuits at all levels. In large HDL programs, there is a need for
                  source code reduction techniques to address a myriad of problems in
                  design, simulation, testing, and formal verification. Program
                  slicing is a static program analysis technique that allows an
                  analyst to automatically extract portions of programs relevant to
                  the aspects being analyzed. Slicing is fundamentally based on data
                  and control dependences between program points. However, program
                  slicing algorithms have traditionally been designed for sequential
                  languages, and the presence of concurrent constructs such as those
                  found in HDLs complicates slicing considerably. In this paper, we
                  develop the concepts needed for slicing VHDL. The techniques extend
                  readily to other HDLs such as Verilog. Our techniques are based on
                  a slicing-oriented VHDL execution semantics that augments
                  traditional dependences with inter-procedural dependences between
                  VHDL processes. Based on these concepts, we have developed an
                  automatic VHDL slicing tool composed of a traditional slicer and a
                  front-end that captures VHDL simulation semantics. This paper
                  discusses our techniques for VHDL slicing, the slicer tool, and
                  slicing applications in design, simulation, testing, and formal
                  verification of VHDL programs. A particularly important application
                  of HDL slicing is source code reduction leading to reduced state
                  spaces for model checking, and we also present empirical results
                  for this.},
  issn =         {1433-2779},
  doi =          {10.1007/s100090100069},
  url =          {https://doi.org/10.1007/s100090100069}
}

@InProceedings{myreen-tacas2007,
  author =       "Myreen, Magnus O.  and Gordon, Michael J. C.",
  editor =       "Grumberg, Orna and Huth, Michael",
  title =        "Hoare Logic for Realistically Modelled Machine Code",
  booktitle =    "Tools and Algorithms for the Construction and Analysis of Systems",
  year =         "2007",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "568--582",
  abstract =     "This paper presents a mechanised Hoare-style programming logic
                  framework for assembly level programs. The framework has been
                  designed to fit on top of operational semantics of realistically
                  modelled machine code. Many ad hoc restrictions and features
                  present in real machine-code are handled, including finite memory,
                  data and code in the same memory space, the behavior of status
                  registers and hazards of corrupting special purpose registers
                  (e.g. the program counter, procedure return register and stack
                  pointer). Despite accurately modeling such low level details, the
                  approach yields concise specifications for machine-code programs
                  without using common simplifying assumptions (like an unbounded
                  state space). The framework is based on a flexible state
                  representation in which functional and resource usage
                  specifications are written in a style inspired by separation
                  logic. The presented work has been formalised in higher-order
                  logic, mechanised in the HOL4 system and is currently being used to
                  verify ARM machine-code implementations of arithmetic and
                  cryptographic operations.",
  isbn =         "978-3-540-71209-1"
}


@InProceedings{myreen-fsen2007,
  author =       "Myreen, Magnus O.  and Fox, Anthony C. J.  and Gordon, Michael
                  J. C.",
  editor =       "Arbab, Farhad and Sirjani, Marjan",
  title =        "Hoare Logic for ARM Machine Code",
  booktitle =    "International Symposium on Fundamentals of Software Engineering",
  year =         "2007",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "272--286",
  abstract =     "This paper shows how a machine-code Hoare logic is used to lift
                  reasoning from the tedious operational model of a machine language
                  to a manageable level of abstraction without making simplifying
                  assumptions. A Hoare logic is placed on top of a high-fidelity
                  model of the ARM instruction set. We show how the generality of ARM
                  instructions is captured by specifications in the logic and how the
                  logic can be used to prove loops and procedures that traverse
                  pointer-based data structures. The presented work has been
                  mechanised in the HOL4 theorem prover and is currently being used
                  to verify ARM machine code implementations of arithmetic and
                  cryptographic operations.",
  isbn =         "978-3-540-75698-9"
}

@article{lamport-actainf1980,
  author =       {Lamport, Leslie},
  title =        {The `Hoare Logic' of Concurrent Programs},
  year =         {1980},
  issue_date =   {June 1980},
  publisher =    {Springer-Verlag},
  address =      {Berlin, Heidelberg},
  volume =       {14},
  number =       {1},
  issn =         {0001-5903},
  url =          {https://doi.org/10.1007/BF00289062},
  doi =          {10.1007/BF00289062},
  abstract =     {Hoare's logical system for specifying and proving partial
                  correctness properties of sequential programs is generalized to
                  concurrent programs. The basic idea is to define the assertion {P}
                  S {Q} to mean that if execution is begun anywhere in S with P true,
                  then P will remain true until S terminates, and Q will be true if
                  and when S terminates. The predicates P and Q may depend upon
                  program control locations as well as upon the values of
                  variables. A system of inference rules and axiom schemas is given,
                  and a formal correctness proof for a simple program is outlined. We
                  show that by specifying certain requirements for the unimplemented
                  parts, correctness properties can be proved without completely
                  implementing the program. The relation to Pnueli's temporal logic
                  formalism is also discussed.},
  journal =      {Acta Inf.},
  month =        jun,
  pages =        {21–37},
  numpages =     {17}
}

@InProceedings{abadi-icfem2005,
  author =       "Abadi, Mart{\'i}n and Budiu, Mihai and Erlingsson, {\'U}lfar and
                  Ligatti, Jay",
  editor =       "Lau, Kung-Kiu and Banach, Richard",
  title =        "A Theory of Secure Control Flow",
  booktitle =    "Formal Methods and Software Engineering",
  year =         "2005",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "111--124",
  abstract =     "Control-Flow Integrity (CFI) means that the execution of a program
                  dynamically follows only certain paths, in accordance with a static
                  policy. CFI can prevent attacks that, by exploiting buffer
                  overflows and other vulnerabilities, attempt to control program
                  behavior. This paper develops the basic theory that underlies two
                  practical techniques for CFI enforcement, with precise formulations
                  of hypotheses and guarantees.",
  isbn =         "978-3-540-32250-4"
}

@inproceedings{coppelia-zhang-micro2018,
  author =       {Zhang, Rui and Deutschbein, Calvin and Huang, Peng and Sturton,
                  Cynthia},
  title =        {End-to-End Automated Exploit Generation for Validating the Security
                  of Processor Designs},
  year =         {2018},
  isbn =         {9781538662403},
  publisher =    {IEEE Press},
  url =          {https://doi.org/10.1109/MICRO.2018.00071},
  doi =          {10.1109/MICRO.2018.00071},
  abstract =     {This paper presents Coppelia, an end-to-end tool that, given a
                  processor design and a set of security-critical invariants,
                  automatically generates complete, replayable exploit programs to
                  help designers find, contextualize, and assess the security threat
                  of hardware vulnerabilities. In Coppelia, we develop a
                  hardware-oriented backward symbolic execution engine with a new
                  cycle stitching method and fast validation technique, along with
                  several optimizations for exploit generation. We then add program
                  stubs to complete the exploit. We evaluate Coppelia on three CPUs
                  of different architectures. Coppelia is able to find and generate
                  exploits for 29 of 31 known vulnerabilities in these CPUs,
                  including 11 vulnerabilities that commercial and academic model
                  checking tools can not find. All of the generated exploits are
                  successfully replayable on an FPGA board. Moreover, Coppelia finds
                  4 new vulnerabilities along with exploits in these CPUs. We also
                  use Coppelia to verify whether a security patch indeed fixed a
                  vulnerability, and to refine a set of assertions.},
  booktitle =    {Proceedings of the 51st Annual IEEE/ACM International Symposium on
                  Microarchitecture},
  pages =        {815–827},
  numpages =     {13},
  keywords =     {symbolic execution, processor security, exploit generation},
  location =     {Fukuoka, Japan},
  series =       {MICRO-51}
}

@inproceedings{zarf-mcmahan-asplos2017,
  author =       {McMahan, Joseph and Christensen, Michael and Nichols, Lawton and
                  Roesch, Jared and Guo, Sung-Yee and Hardekopf, Ben and Sherwood,
                  Timothy},
  title =        {An Architecture Supporting Formal and Compositional Binary
                  Analysis},
  year =         {2017},
  isbn =         {9781450344654},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3037697.3037733},
  doi =          {10.1145/3037697.3037733},
  abstract =     {Building a trustworthy life-critical embedded system requires deep
                  reasoning about the potential effects that sequences of machine
                  instructions can have on full system operation. Rather than trying
                  to analyze complete binaries and the countless ways their
                  instructions can interact with one another --- memory, side
                  effects, control registers, implicit state, etc. --- we explore a
                  new approach. We propose an architecture controlled by a thin
                  computational layer designed to tightly correspond with the lambda
                  calculus, drawing on principles of functional programming to bring
                  the assembly much closer to myriad reasoning frameworks, such as
                  the Coq proof assistant. This approach allows assembly-level
                  verified versions of critical code to operate safely in tandem with
                  arbitrary code, including imperative and unverified system
                  components, without the need for large supporting trusted computing
                  bases. We demonstrate that this computational layer can be built in
                  such a way as to simultaneously provide full programmability and
                  compact, precise, and complete semantics, while still using
                  hardware resources comparable to normal embedded systems. To
                  demonstrate the practicality of this approach, our FPGA-implemented
                  prototype runs an embedded medical application which monitors and
                  treats life-threatening arrhythmias. Though the system integrates
                  untrusted and imperative components, our architecture allows for
                  the formal verification of multiple properties of the end-to-end
                  system, including a proof of correctness of the assembly-level
                  implementation of the core algorithm, the integrity of trusted data
                  via a non-interference proof, and a guarantee that our prototype
                  meets critical timing requirements.},
  booktitle =    {Proceedings of the Twenty-Second International Conference on
                  Architectural Support for Programming Languages and Operating
                  Systems},
  pages =        {177–191},
  numpages =     {15},
  keywords =     {isa semantics, binary verification, assembly analysis,
                  heterogeneous architecture, static analysis, non-interference,
                  functional programming, formal methods},
  location =     {Xi'an, China},
  series =       {ASPLOS '17}
}

@INPROCEEDINGS{nacl-yee-oakland2009,
  author =       {B. {Yee} and D. {Sehr} and G. {Dardyk} and J. B. {Chen} and
                  R. {Muth} and T. {Ormandy} and S. {Okasaka} and N. {Narula} and
                  N. {Fullagar}},
  booktitle =    {2009 30th IEEE Symposium on Security and Privacy},
  title =        {Native Client: A Sandbox for Portable, Untrusted x86 Native Code},
  year =         {2009},
  volume =       {},
  number =       {},
  pages =        {79-93},
  abstract =     {This paper describes the design, implementation and evaluation of
                  Native Client, a sandbox for untrusted x86 native code. Native
                  Client aims to give browser-based applications the computational
                  performance of native applications without compromising
                  safety. Native Client uses software fault isolation and a secure
                  runtime to direct system interaction and side effects through
                  interfaces managed by Native Client. Native Client provides
                  operating system portability for binary code while supporting
                  performance-oriented features generally absent from Web application
                  programming environments, such as thread support, instruction set
                  extensions such as SSE, and use of compiler intrinsics and
                  hand-coded assembler. We combine these properties in an open
                  architecture that encourages community review and 3rd-party tools.},
  keywords =     {computer interfaces;Internet;online front-ends;security of
                  data;software performance evaluation;Native
                  client;sandbox;untrusted x86 native code;browser-based
                  applications;software fault isolation;operating system
                  portability;binary code;Web application programming
                  environments;thread support;instruction set extensions;hand-coded
                  assembler;open architecture;Application software;Security;Operating
                  systems;Yarn;Assembly systems;Manuals;Java;High performance
                  computing;Physics computing;Privacy;Security;World Wide Web},
  doi =          {10.1109/SP.2009.25},
  ISSN =         {2375-1207},
  month =        {May},
}

@TECHREPORT{mccamant:mitcsailtr2005,
  AUTHOR =       {McCamant, Stephen and Morrisett, Greg},
  TITLE =        {Efficient, Verifiable Binary Sandboxing for a CISC Architecture},
  NUMBER =       {MIT-CSAIL-TR-2005-030},
  INSTITUTION =  {Massachusetts Institute of Technology Computer Science and
                  Artificial Intelligence Laboratory},
  ABSTRACT =     {Executing untrusted code while preserving security
                  requiresenforcement of memory and control-flow safety
                  policies:untrusted code must be prevented from modifying memory
                  orexecuting code except as explicitly allowed. Software-basedfault
                  isolation (SFI) or "sandboxing" enforces thosepolicies by
                  rewriting the untrusted code at the level ofindividual
                  instructions. However, the original sandboxingtechnique of Wahbe et
                  al. is applicable only to RISCarchitectures, and other previous
                  work is either insecure,or has been not described in enough detail
                  to giveconfidence in its security properties. We present a
                  noveltechnique that allows sandboxing to be easily applied to aCISC
                  architecture like the IA-32. The technique can beverified to have
                  been applied at load time, so that neitherthe rewriting tool nor
                  the compiler needs to be trusted. Wedescribe a prototype
                  implementation which provides a robustsecurity guarantee, is
                  scalable to programs of any size, andhas low runtime
                  overheads. Further, we give amachine-checked proof that any program
                  approved by theverification algorithm is guaranteed to respect the
                  desiredsafety property.},
  MONTH =        {05},
  YEAR =         {2005},
  URL =          {http://hdl.handle.net/1721.1/30542}
}

@inproceedings{webassembly-haas-2017,
  author =       {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and
                  Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke
                  and Zakai, Alon and Bastien, JF},
  title =        {Bringing the Web up to Speed with WebAssembly},
  year =         {2017},
  isbn =         {9781450349888},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3062341.3062363},
  doi =          {10.1145/3062341.3062363},
  abstract =     { The maturation of the Web platform has given rise to sophisticated
                  and demanding Web applications such as interactive 3D
                  visualization, audio and video software, and games. With that,
                  efficiency and security of code on the Web has become more
                  important than ever. Yet JavaScript as the only built-in language
                  of the Web is not well-equipped to meet these requirements,
                  especially as a compilation target.  Engineers from the four major
                  browser vendors have risen to the challenge and collaboratively
                  designed a portable low-level bytecode called WebAssembly. It
                  offers compact representation, efficient validation and
                  compilation, and safe low to no-overhead execution. Rather than
                  committing to a specific programming model, WebAssembly is an
                  abstraction over modern hardware, making it language-, hardware-,
                  and platform-independent, with use cases beyond just the
                  Web. WebAssembly has been designed with a formal semantics from the
                  start. We describe the motivation, design and formal semantics of
                  WebAssembly and provide some preliminary experience with
                  implementations. },
  booktitle =    {Proceedings of the 38th ACM SIGPLAN Conference on Programming
                  Language Design and Implementation},
  pages =        {185–200},
  numpages =     {16},
  keywords =     {programming languages, virtual machines, type systems, just-in-time
                  compilers, assembly languages},
  location =     {Barcelona, Spain},
  series =       {PLDI 2017}
}

@inproceedings{lehmann-usenixsec2020,
  title =        {Everything Old is New Again: Binary Security of WebAssembly},
  author =       {Lehmann, Daniel and Kinder, Johannes and Pradel, Michael},
  booktitle =    {29th {USENIX} Security Symposium ({USENIX} Security
                  20)},
  pages =        {217--234},
  year =         {2020}
}

@inproceedings{sehr-usenixsec2010,
  author =       {Sehr, David and Muth, Robert and Biffle, Cliff and Khimenko, Victor
                  and Pasko, Egor and Schimpf, Karl and Yee, Bennet and Chen, Brad},
  title =        {Adapting Software Fault Isolation to Contemporary CPU
                  Architectures},
  year =         {2010},
  isbn =         {8887666655554},
  publisher =    {USENIX Association},
  address =      {USA},
  abstract =     {Software Fault Isolation (SFI) is an effective approach to
                  sandboxing binary code of questionable provenance, an interesting
                  use case for native plugins in a Web browser. We present software
                  fault isolation schemes for ARM and x86-64 that provide
                  control-flow and memory integrity with average performance overhead
                  of under 5\% on ARM and 7\% on x86-64. We believe these are the
                  best known SFI implementations for these architectures, with
                  significantly lower overhead than previous systems for similar
                  architectures. Our experience suggests that these SFI
                  implementations benefit from instruction-level parallelism, and
                  have particularly small impact for workloads that are data
                  memory-bound, both properties that tend to reduce the impact of our
                  SFI systems for future CPU implementations.},
  booktitle =    {Proceedings of the 19th USENIX Conference on Security},
  location =     {Washington, DC},
  series =       {USENIX Security'10}
}

@manual{ARMv7-M-Manual,
  key = {ARM},
  title = {ARMv7-M Architecture Reference Manual},
  organization = {Arm Holdings},
  month = {June},
  year = {2018},
  note = {{DDI} 0403E.d},
}
@INPROCEEDINGS{lift-steuwer-cgo2017,
  author =       {M. {Steuwer} and T. {Remmelg} and C. {Dubach}},
  booktitle =    {2017 IEEE/ACM International Symposium on Code Generation and
                  Optimization (CGO)},
  title =        {LIFT: A functional data-parallel IR for high-performance GPU code
                  generation},
  year =         {2017},
  volume =       {},
  number =       {},
  pages =        {74-85},
  abstract =     {Parallel patterns (e.g., map, reduce) have gained traction as an
                  abstraction for targeting parallel accelerators and are a promising
                  answer to the performance portability problem. However, compiling
                  high-level programs into efficient low-level parallel code is
                  challenging. Current approaches start from a high-level parallel IR
                  and proceed to emit GPU code directly in one big step. Fixed
                  strategies are used to optimize and map parallelism exploiting
                  properties of a particular GPU generation leading to performance
                  portability issues. We introduce the LIFT IR, a new data-parallel
                  IR which encodes OpenCL-specific constructs as functional
                  patterns. Our prior work has shown that this functional nature
                  simplifies the exploration of optimizations and mapping of
                  parallelism from portable high-level programs using
                  rewrite-rules. This paper describes how LIFT IR programs are
                  compiled into efficient OpenCL code. This is non-trivial as many
                  performance sensitive details such as memory allocation, array
                  accesses or synchronization are not explicitly represented in the
                  LIFT IR. We present techniques which overcome this challenge by
                  exploiting the pattern's high-level semantics. Our evaluation shows
                  that the LIFT IR is flexible enough to express GPU programs with
                  complex optimizations achieving performance on par with manually
                  optimized code.},
  keywords =     {graphics processing units;optimisation;parallel
                  processing;performance evaluation;program compilers;functional
                  data-parallel IR;high-performance GPU code generation;parallel
                  patterns;gained traction;parallel accelerators;performance
                  portability problem;compiling high-level programs;low-level
                  parallel code;GPU generation;functional patterns;portable
                  high-level programs;OpenCL code;complex optimizations;Graphics
                  processing units;Optimization;Parallel
                  processing;Semantics;Arrays;Resource management;Synchronization},
  doi =          {10.1109/CGO.2017.7863730},
  ISSN =         {},
  month =        {Feb},
}
@manual{riscv-isa-manual2017,
	editor = {Andrew Waterman1 and Krste Asanović},
	title = {The {RISC-V} Instruction Set Manual: Volume I: User-Level ISA},
	date = {May 7, 2017},
	version = {2.2},
	publisher = {{RISC-V} Foundation},
	month = {May},
	year = {2017},
}
@inproceedings{dasgupta-pldi2020,
  author =       {Dasgupta, Sandeep and Dinesh, Sushant and Venkatesh, Deepan and
                  Adve, Vikram S. and Fletcher, Christopher W.},
  title =        {Scalable Validation of Binary Lifters},
  year =         {2020},
  isbn =         {9781450376136},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3385412.3385964},
  doi =          {10.1145/3385412.3385964},
  abstract =     {Validating the correctness of binary lifters is pivotal to gain
                  trust in binary analysis, especially when used in scenarios where
                  correctness is important. Existing approaches focus on validating
                  the correctness of lifting instructions or basic blocks in
                  isolation and do not scale to full programs. In this work, we show
                  that formal translation validation of single instructions for a
                  complex ISA like x86-64 is not only practical, but can be used as a
                  building block for scalable full-program validation. Our work is
                  the first to do translation validation of single instructions on an
                  architecture as extensive as x86-64, uses the most precise formal
                  semantics available, and has the widest coverage in terms of the
                  number of instructions tested for correctness. Next, we develop a
                  novel technique that uses validated instructions to enable
                  program-level validation, without resorting to performance-heavy
                  semantic equivalence checking. Specifically, we compose the
                  validated IR sequences using a tool we develop called Compositional
                  Lifter to create a reference standard. The semantic equivalence
                  check between the reference and the lifter output is then reduced
                  to a graph-isomorphism check through the use of semantic preserving
                  transformations. The translation validation of instructions in
                  isolation revealed 29 new bugs in McSema – a mature open-source
                  lifter from x86-64 to LLVM IR. Towards the validation of full
                  programs, our approach was able to prove the translational
                  correctness of 2254/2348 functions taken from LLVM’s single-source
                  benchmark test-suite.},
  booktitle =    {Proceedings of the 41st ACM SIGPLAN Conference on Programming
                  Language Design and Implementation},
  pages =        {655–671},
  numpages =     {17},
  keywords =     {LLVM IR, x86-64, Formal Semantics, Compiler Optimizations,
                  Translation Validation, Graph Isomorphism},
  location =     {London, UK},
  series =       {PLDI 2020}
}
@inproceedings{dasgupta-pldi2019,
  author =       {Dasgupta, Sandeep and Park, Daejun and Kasampalis, Theodoros and
                  Adve, Vikram S. and Ro\c{s}u, Grigore},
  title =        {A Complete Formal Semantics of X86-64 User-Level Instruction Set
                  Architecture},
  year =         {2019},
  isbn =         {9781450367127},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3314221.3314601},
  doi =          {10.1145/3314221.3314601},
  abstract =     {We present the most complete and thoroughly tested formal semantics
                  of x86-64 to date. Our semantics faithfully formalizes all the
                  non-deprecated, sequential user-level instructions of the x86-64
                  Haswell instruction set architecture. This totals 3155 instruction
                  variants, corresponding to 774 mnemonics. The semantics is fully
                  executable and has been tested against more than 7,000
                  instruction-level test cases and the GCC torture test suite. This
                  extensive testing paid off, revealing bugs in both the x86-64
                  reference manual and other existing semantics. We also illustrate
                  potential applications of our semantics in different formal
                  analyses, and discuss how it can be useful for processor
                  verification.},
  booktitle =    {Proceedings of the 40th ACM SIGPLAN Conference on Programming
                  Language Design and Implementation},
  pages =        {1133–1148},
  numpages =     {16},
  keywords =     {ISA specification, x86-64, Formal Semantics},
  location =     {Phoenix, AZ, USA},
  series =       {PLDI 2019}
}
@inproceedings{baghsorkhi-ppopp2010,
  author =       {Baghsorkhi, Sara S. and Delahaye, Matthieu and Patel, Sanjay J. and
                  Gropp, William D. and Hwu, Wen-mei W.},
  title =        {An Adaptive Performance Modeling Tool for GPU Architectures},
  year =         {2010},
  isbn =         {9781605588773},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/1693453.1693470},
  doi =          {10.1145/1693453.1693470},
  abstract =     {This paper presents an analytical model to predict the performance
                  ofgeneral-purpose applications on a GPU architecture. The model is
                  designed to provide performance information to an auto-tuning
                  compiler and assist it in narrowing down the search to the more
                  promising implementations. It can also be incorporated into a tool
                  to help programmers better assess the performance bottlenecks in
                  their code. We analyze each GPU kernel and identify how the kernel
                  exercises major GPU microarchitecture features. To identify the
                  performance bottlenecks accurately, we introduce an abstract
                  interpretation of a GPU kernel, work flow graph, based on which we
                  estimate the execution time of a GPU kernel. We validated our
                  performance model on the NVIDIA GPUs using CUDA (Compute Unified
                  Device Architecture). For this purpose, we used data parallel
                  benchmarks that stress different GPU microarchitecture events such
                  as uncoalesced memory accesses, scratch-pad memory bank conflicts,
                  and control flow divergence, which must be accurately modeled but
                  represent challenges to the analytical performance models. The
                  proposed model captures full system complexity and shows high
                  accuracy in predicting the performance trends of different
                  optimized kernel implementations. We also describe our approach to
                  extracting the performance model automatically from a kernel code.},
  booktitle =    {Proceedings of the 15th ACM SIGPLAN Symposium on Principles and
                  Practice of Parallel Programming},
  pages =        {105–114},
  numpages =     {10},
  keywords =     {gpu, performance estimation, parallel programming, analytical
                  model},
  location =     {Bangalore, India},
  series =       {PPoPP '10}
}

@INPROCEEDINGS{nienhuis:oakland2020,
  author =       {K. {Nienhuis} and A. {Joannou} and T. {Bauereiss} and A. {Fox} and
                  M. {Roe} and B. {Campbell} and M. {Naylor} and R. M. {Norton} and
                  S. W. {Moore} and P. G. {Neumann} and I. {Stark} and
                  R. N. M. {Watson} and P. {Sewell}},
  booktitle =    {2020 IEEE Symposium on Security and Privacy (SP)},
  title =        {Rigorous engineering for hardware security: Formal modelling and
                  proof in the CHERI design and implementation process},
  year =         {2020},
  volume =       {},
  number =       {},
  pages =        {1003-1020},
  abstract =     {The root causes of many security vulnerabilities include a
                  pernicious combination of two problems, often regarded as
                  inescapable aspects of computing. First, the protection mechanisms
                  provided by the mainstream processor architecture and C/C++
                  language abstractions, dating back to the 1970s and before, provide
                  only coarse-grain virtual-memory-based protection. Second,
                  mainstream system engineering relies almost exclusively on
                  test-and-debug methods, with (at best) prose specifications. These
                  methods have historically sufficed commercially for much of the
                  computer industry, but they fail to prevent large numbers of
                  exploitable bugs, and the security problems that this causes are
                  becoming ever more acute.In this paper we show how more rigorous
                  engineering methods can be applied to the development of a new
                  security-enhanced processor architecture, with its accompanying
                  hardware implementation and software stack. We use formal models of
                  the complete instruction-set architecture (ISA) at the heart of the
                  design and engineering process, both in lightweight ways that
                  support and improve normal engineering practice - as documentation,
                  in emulators used as a test oracle for hardware and for running
                  software, and for test generation - and for formal verification. We
                  formalise key intended security properties of the design, and
                  establish that these hold with mechanised proof. This is for the
                  same complete ISA models (complete enough to boot operating
                  systems), without idealisation.We do this for CHERI, an
                  architecture with hardware capabilities that supports fine-grained
                  memory protection and scalable secure compartmentalisation, while
                  offering a smooth adoption path for existing software. CHERI is a
                  maturing research architecture, developed since 2010, with work now
                  underway on an Arm industrial prototype to explore its possible
                  adoption in mass-market commercial processors. The rigorous
                  engineering work described here has been an integral part of its
                  development to date, enabling more rapid and confident
                  experimentation, and boosting confidence in the design.},
  keywords =     {C++ language;computer architecture;formal verification;instruction
                  sets;microprocessor chips;multiprocessing systems;operating systems
                  (computers);program debugging;program testing;security of
                  data;hardware security;CHERI design;security
                  vulnerabilities;protection mechanisms;mainstream processor
                  architecture;coarse-grain virtual-memory-based
                  protection;mainstream system engineering;computer
                  industry;security-enhanced processor architecture;instruction-set
                  architecture;engineering process;test generation;formal
                  verification;mechanised proof;operating systems;hardware
                  capabilities;fine-grained memory protection;Arm industrial
                  prototype;C language abstractions;C++ language
                  abstractions;test-and-debug methods;ISA
                  models;oracle;Security;Hardware;Software;Computer bugs;Memory
                  management;Testing},
  doi =          {10.1109/SP40000.2020.00055},
  ISSN =         {2375-1207},
  month =        {May},
}

@inproceedings{gross-ashes2019,
  author =       {Gross, Mathieu and Jacob, Nisha and Zankl, Andreas and
                  Sigl, Georg},
  title =        {Breaking TrustZone Memory Isolation through Malicious
                  Hardware on a Modern FPGA-SoC},
  year =         {2019},
  isbn =         {9781450368391},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3338508.3359568},
  doi =          {10.1145/3338508.3359568},
  abstract =     {FPGA-SoCs are heterogeneous computing systems consisting
                  of reconfigurable hardware and high performance
                  processing units. This combination enables a flexible
                  design methodology for embedded systems. However, the
                  sharing of resources between these heterogeneous systems
                  opens the door to attacks from one system on the
                  other. This work considers Direct Memory Access attacks
                  from a malicious hardware block inside the reconfigurable
                  logic on the CPU. Previous works have shown similar
                  attacks on FPGA-SoCs containing no memory isolation
                  between the FPGA and the CPU. Our work studies the same
                  idea on a system based on the Xilinx Zynq Ultrascale+
                  architecture. This platform contains memory isolation
                  mechanisms such as a system memory management unit,
                  memory protection units and supports ARM TrustZone
                  technology. Despite the existence of these protection
                  mechanisms, the two attacks presented in this work show
                  that a malicious hardware block can still interfere with
                  a security critical task executed on the CPU inside ARM
                  TrustZone},
  booktitle =    {Proceedings of the 3rd ACM Workshop on Attacks and
                  Solutions in Hardware Security Workshop},
  pages =        {3–12},
  numpages =     {10},
  keywords =     {memory isolation, hardware trojan, trusted execution
                  environment, trustzone, fpga-socs, dma attack},
  location =     {London, United Kingdom},
  series =       {ASHES'19}
}

@inproceedings{proy-ares2019,
  author =       {Proy, Julien and Heydemann, Karine and Berzati, Alexandre
                  and Maj\'{e}ric, Fabien and Cohen, Albert},
  title =        {A First ISA-Level Characterization of EM Pulse Effects on
                  Superscalar Microarchitectures: A Secure Software
                  Perspective},
  year =         {2019},
  isbn =         {9781450371643},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3339252.3339253},
  doi =          {10.1145/3339252.3339253},
  abstract =     {In the area of physical attacks, system-on-chip (SoC)
                  designs have not received the same level of attention as
                  simpler micro-controllers. We try to model the behavior
                  of secure software running on a superscalar out-of-order
                  microprocessor typical of more complex SoC, in the
                  presence of electromagnetic (EM) pulses. We first show
                  that it is possible, in a black box approach, to corrupt
                  the loop iteration count of both original and hardened
                  versions of two sensitive loops. We propose a
                  characterization methodology based on very simple codes,
                  to understand and classify the fault effects at the level
                  of the instruction set architecture (ISA). The resulting
                  classification includes the well established instruction
                  skip and register corruption models, as well as new
                  effects specific to more complex processors, such as
                  operand substitution, multiple correlated register
                  corruptions, advanced control-flow hijacking, and
                  combinations of all reported effects. This diversity and
                  complexity of effects can lead to powerful attacks. The
                  proposed methodology and fault classification at ISA
                  level is a first step towards a more complete
                  characterization. It is also a tool supporting the
                  designers of software and hardware countermeasures.},
  booktitle =    {Proceedings of the 14th International Conference on
                  Availability, Reliability and Security},
  articleno =    {7},
  numpages =     {10},
  keywords =     {electromagnetic pulse injection, countermeasures to
                  physical attacks, superscalar out-of-order, fault models},
  location =     {Canterbury, CA, United Kingdom},
  series =       {ARES '19}
}
@INPROCEEDINGS{designobfus-chakraborty-iccad2009,
  author =       {R. S. {Chakraborty} and S. {Bhunia}},
  booktitle =    {2009 IEEE/ACM International Conference on Computer-Aided
                  Design - Digest of Technical Papers},
  title =        {Security against hardware Trojan through a novel
                  application of design obfuscation},
  year =         {2009},
  volume =       {},
  number =       {},
  pages =        {113-116},
  abstract =     {Malicious hardware Trojan circuitry inserted in
                  safety-critical applications is a major threat to
                  national security. In this work, we propose a novel
                  application of a key-based obfuscation technique to
                  achieve security against hardware Trojans. The
                  obfuscation scheme is based on modifying the state
                  transition function of a given circuit by expanding its
                  reachable state space and enabling it to operate in two
                  distinct modes - the normal mode and the obfuscated
                  mode. Such a modification obfuscates the rareness of the
                  internal circuit nodes, thus making it difficult for an
                  adversary to insert hard-to-detect Trojans. It also makes
                  some inserted Trojans benign by making them activate only
                  in the obfuscated mode. The combined effect leads to
                  higher Trojan detectability and higher level of
                  protection against such attack. Simulation results for a
                  set of benchmark circuits show that the scheme is capable
                  of achieving high levels of security at modest design
                  overhead.},
  keywords =     {Hardware;Information security;Protection;National
                  security;State-space methods;Circuit simulation;Circuit
                  testing;Permission;Computational modeling;Logic
                  design;Design obfuscation;hardware security;hardware
                  Trojan},
  doi =          {10.1145/1687399.1687424},
  ISSN =         {1558-2434},
  month =        {Nov},
}
@Article{designobfus-chakraborty-jet2011,
  author =       {Chakraborty, Rajat Subhra and Bhunia, Swarup},
  title =        {Security Against Hardware Trojan Attacks Using Key-Based
                  Design Obfuscation},
  journal =      {Journal of Electronic Testing},
  year =         {2011},
  month =        {Dec},
  day =          {01},
  volume =       {27},
  number =       {6},
  pages =        {767-785},
  abstract =     {Malicious modification of hardware in untrusted
                  fabrication facilities, referred to as hardware Trojan,
                  has emerged as a major security concern. Comprehensive
                  detection of these Trojans during post-manufacturing test
                  has been shown to be extremely difficult. Hence, it is
                  important to develop design techniques that provide
                  effective countermeasures against hardware Trojans by
                  either preventing Trojan attacks or facilitating
                  detection during test. Obfuscation is a technique that is
                  conventionally employed to prevent piracy of software and
                  hardware intellectual property (IP). In this work, we
                  propose a novel application of key-based circuit
                  structure and functionality obfuscation to achieve
                  protection against hardware Trojans triggered by rare
                  internal circuit conditions. The proposed obfuscation
                  scheme is based on judicious modification of the state
                  transition function, which creates two distinct
                  functional modes: normal and obfuscated. A circuit
                  transitions from the obfuscated to the normal mode only
                  upon application of a specific input sequence, which
                  defines the key. We show that it provides security
                  against Trojan attacks in two ways: (1) it makes some
                  inserted Trojans benign, i.e. they become effective only
                  in the obfuscated mode; and (2) it prevents an adversary
                  from exploiting the true rare events in a circuit to
                  insert hard-to-detect Trojans. The proposed design
                  methodology can thus achieve simultaneous protection from
                  hardware Trojans and hardware IP piracy. Besides
                  protecting ICs against Trojan attacks in foundry, we show
                  that it can also protect against malicious modifications
                  by untrusted computer-aided design (CAD) tools in both
                  SoC and FPGA design flows. Simulation results for a set
                  of benchmark circuits show that the scheme is capable of
                  achieving high levels of security against Trojan attacks
                  at modest area, power and delay overhead.},
  issn =         {1573-0727},
  doi =          {10.1007/s10836-011-5255-2},
  url =          {https://doi.org/10.1007/s10836-011-5255-2}
}

@INPROCEEDINGS{icas-trippel-oakland2020,
  author =       {T. {Trippel} and K. G. {Shin} and K. B. {Bush} and
                  M. {Hicks}},
  booktitle =    {2020 IEEE Symposium on Security and Privacy (SP)},
  title =        {{ICAS}: an Extensible Framework for Estimating the
                  Susceptibility of IC Layouts to Additive Trojans},
  year =         {2020},
  volume =       {},
  number =       {},
  pages =        {1742-1759},
  abstract =     {The transistors used to construct Integrated Circuits
                  (ICs) continue to shrink. While this shrinkage improves
                  performance and density, it also reduces trust: the price
                  to build leading-edge fabrication facilities has
                  skyrocketed, forcing even nation states to outsource the
                  fabrication of high-performance ICs. Outsourcing
                  fabrication presents a security threat because the
                  black-box nature of a fabricated IC makes comprehensive
                  inspection infeasible. Since prior work shows the
                  feasibility of fabrication-time attackers' evasion of
                  existing post-fabrication defenses, IC designers must be
                  able to protect their physical designs before handing
                  them off to an untrusted foundry. To this end, recent
                  work suggests methods to harden IC layouts against
                  attack. Unfortunately, no tool exists to assess the
                  effectiveness of the proposed defenses, thus leaving
                  defensive gaps.This paper presents an extensible IC
                  layout security analysis tool called IC Attack Surface
                  (ICAS) that quantifies defensive coverage. For
                  researchers, ICAS identifies gaps for future defenses to
                  target, and enables the quantitative comparison of
                  existing and future defenses. For practitioners, ICAS
                  enables the exploration of the impact of design decisions
                  on an IC's resilience to fabrication-time attack. ICAS
                  takes a set of metrics that encode the challenge of
                  inserting a hardware Trojan into an IC layout, a set of
                  attacks that the defender cares about, and a completed IC
                  layout and reports the number of ways an attacker can add
                  each attack to the design. While the ideal score is zero,
                  practically, we find that lower scores correlate with
                  increased attacker effort.To demonstrate ICAS' ability to
                  reveal defensive gaps, we analyze over 60 layouts of
                  three real-world hardware designs (a processor, AES and
                  DSP accelerators), protected with existing defenses. We
                  evaluate the effectiveness of each circuit-defense
                  combination against three representative attacks from the
                  literature. Results show that some defenses are
                  ineffective and others, while effective at reducing the
                  attack surface, leave 10's to 1000's of unique attack
                  implementations that an attacker can exploit.},
  keywords =     {Integrated circuits;Trojan
                  horses;Hardware;Layout;Payloads;Foundries;Fabrication},
  doi =          {10.1109/SP40000.2020.00083},
  ISSN =         {2375-1207},
  month =        {May},
}
@inproceedings{llvmcfi-zeng-ccs2011,
  author =       {Zeng, Bin and Tan, Gang and Morrisett, Greg},
  title =        {Combining Control-Flow Integrity and Static Analysis for
                  Efficient and Validated Data Sandboxing},
  year =         {2011},
  isbn =         {9781450309486},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/2046707.2046713},
  doi =          {10.1145/2046707.2046713},
  abstract =     {In many software attacks, inducing an illegal
                  control-flow transfer in the target system is one common
                  step. Control-Flow Integrity (CFI) protects a software
                  system by enforcing a pre-determined control-flow
                  graph. In addition to providing strong security, CFI
                  enables static analysis on low-level code. This paper
                  evaluates whether CFI-enabled static analysis can help
                  build efficient and validated data sandboxing. Previous
                  systems generally sandbox memory writes for integrity,
                  but avoid protecting confidentiality due to the high
                  overhead of sandboxing memory reads. To reduce overhead,
                  we have implemented a series of optimizations that remove
                  sandboxing instructions if they are proven unnecessary by
                  static analysis. On top of CFI, our system adds only 2.7%
                  runtime overhead on SPECint2000 for sandboxing memory
                  writes and adds modest 19% for sandboxing both reads and
                  writes. We have also built a principled data-sandboxing
                  verifier based on range analysis. The verifier checks the
                  safety of the results of the optimizer, which removes the
                  need to trust the rewriter and optimizer. Our results
                  show that the combination of CFI and static analysis has
                  the potential of bringing down the cost of general
                  inlined reference monitors, while maintaining strong
                  security.},
  booktitle =    {Proceedings of the 18th ACM Conference on Computer and
                  Communications Security},
  pages =        {29–40},
  numpages =     {12},
  keywords =     {static analysis, inlined reference monitors, control-flow
                  integrity, binary rewriting},
  location =     {Chicago, Illinois, USA},
  series =       {CCS '11}
}

@misc{clang-llvm-cfi,
  title =        {Clang/LLVM 12 Documentation - Control Flow Integrity},
  howpublished =
                  {\url{https://clang.llvm.org/docs/ControlFlowIntegrity.html}},
  note =         {Accessed: 2021-04-01}
}
@misc{aosp-llvm-sanitizers,
  title =        {AOSP LLVM Sanitizers},
  howpublished =
                  {\url{https://source.android.com/devices/tech/debug/sanitizers}},
  note =         {Accessed: 2021-04-01}
}
@book{java-lang-spec-3rd-gosling2005,
  author =       {Gosling, James and Joy, Bill and Steele, Guy and Bracha,
                  Gilad},
  title =        {Java(TM) Language Specification, The (3rd Edition) (Java
                  (Addison-Wesley))},
  year =         {2005},
  isbn =         {0321246780},
  publisher =    {Addison-Wesley Professional},
  abstract =     {Written by the inventors of the technology, The Java™
                  Language Specification, Third Edition, is the definitive
                  technical reference for the Java™ programming
                  language. If you want to know the precise meaning of the
                  language's constructs, this is the source for you.The
                  book provides complete, accurate, and detailed coverage
                  of the Java programming language. It provides full
                  coverage of all new features added since the previous
                  edition, including generics, annotations, asserts,
                  autoboxing, enums, for-each loops, variable arity
                  methods, and static import clauses.}
}
@misc{20210419hacksterio_wave_closes_open,
  title =        {Wave {Computing} {Closes} {Its} {MIPS} {Open}
                  {Initiative} with {Immediate} {Effect}, {Zero} {Warning}
                  - {Hackster}.io},
  url =
                  {https://www.hackster.io/news/wave-computing-closes-its-mips-open-initiative-with-immediate-effect-zero-warning-e88b0df9acd0},
  urldate =      {2021-04-09},
  keywords =     {MIPS, MIPS Open, MIPS core, Wave, FPGA, MIPSfpga}
}

@inproceedings{davi-isc2010,
  address =      {Berlin, Heidelberg},
  series =       {Lecture {Notes} in {Computer} {Science}},
  title =        {Privilege {Escalation} {Attacks} on {Android}},
  isbn =         {978-3-642-18178-8},
  doi =          {10.1007/978-3-642-18178-8_30},
  abstract =     {Android is a modern and popular software platform for
                  smartphones. Among its predominant features is an
                  advanced security model which is based on
                  application-oriented mandatory access control and
                  sandboxing. This allows developers and users to restrict
                  the execution of an application to the privileges it has
                  (mandatorily) assigned at installation time. The
                  exploitation of vulnerabilities in program code is hence
                  believed to be confined within the privilege boundaries
                  of an application’s sandbox. However, in this paper we
                  show that a privilege escalation attack is possible. We
                  show that a genuine application exploited at runtime or a
                  malicious application can escalate granted
                  permissions. Our results immediately imply that Android’s
                  security model cannot deal with a transitive permission
                  usage attack and Android’s sandbox model fails as a last
                  resort against malware and sophisticated runtime
                  attacks.},
  language =     {en},
  booktitle =    {Information {Security}},
  publisher =    {Springer},
  author =       {Davi, Lucas and Dmitrienko, Alexandra and Sadeghi,
                  Ahmad-Reza and Winandy, Marcel},
  editor =       {Burmester, Mike and Tsudik, Gene and Magliveras, Spyros
                  and Ilić, Ivana},
  year =         {2011},
  keywords =     {security, attack, Android Application, Android Platform,
                  Attack Scenario, Installation Time, Instruction Sequence,
                  android, buffer overflow},
  pages =        {346--360},
}
@ARTICLE{loop-wang-tifs2019,
  author =       {C. {Wang} and B. {Chen} and Y. {Liu} and H. {Wu}},
  journal =      {IEEE Transactions on Information Forensics and Security},
  title =        {Layered Object-Oriented Programming: Advanced VTable
                  Reuse Attacks on Binary-Level Defense},
  year =         {2019},
  volume =       {14},
  number =       {3},
  pages =        {693-708},
  abstract =     {Vtable reuse attack, as a novel type of code reuse
                  attacks, is introduced to bypass most binary-level
                  control flow integrity enforcement and vtable integrity
                  enforcement. So far, two binary-level defenses (TypeArmor
                  and vfGuard) are proposed to defend against vtable reuse
                  attacks. Both techniques use semantic information as the
                  control flow integrity enforcement policy, i.e.,
                  TypeArmor and vfGuard utilize argument register count and
                  dispatch offset at virtual callsite as the signature to
                  check the validity of target functions, respectively. In
                  this paper, we propose layered object-oriented
                  programming (LOOP), an advanced vtable reuse attack, to
                  show that the coarse-grained control flow integrity
                  strategies are still vulnerable to vtable reuse
                  attacks. In LOOP, we introduce argument expansion gadgets
                  and transfer gadgets to, respectively, bypass TypeArmor
                  and vfGuard. We generalize the characteristics of both
                  gadgets and develop a tool to discover them at the binary
                  level. We demonstrated that under the protection of
                  TypeArmor and vfGuard, Firefox, Adobe Flash Player, and
                  Internet Explorer are all vulnerable to LOOP
                  attacks. Furthermore, we show the availability of
                  argument expansion gadgets and transfer gadgets in common
                  software or libraries.},
  keywords =     {Data security;Object oriented programming;Vtable reuse
                  attacks;control flow integrity},
  doi =          {10.1109/TIFS.2018.2855648},
  ISSN =         {1556-6021},
  month =        {March},
}
@InProceedings{olli-fdtc2006,
  author =       "Vertanen, Olli",
  editor =       "Breveglieri, Luca and Koren, Israel and Naccache, David
                  and Seifert, Jean-Pierre",
  title =        "Java Type Confusion and Fault Attacks",
  booktitle =    "Fault Diagnosis and Tolerance in Cryptography",
  year =         "2006",
  publisher =    "Springer Berlin Heidelberg",
  address =      "Berlin, Heidelberg",
  pages =        "237--251",
  abstract =     "Virtual machines executing high level languages are
                  nowadays found even in small secure embedded systems. We
                  have studied properties of the Java virtual machine and
                  the Java virtual machine language under certain fault
                  attacks. Focused glitching attacks may enforce type
                  confusion situations. Defensive Java virtual machine is
                  prosed as a counter-measure.",
  isbn =         "978-3-540-46251-4"
}


@INPROCEEDINGS{francq-date2015,
  author =       {Francq, Julien and Frick, Florian},
  booktitle =    {2015 Design, Automation Test in Europe Conference
                  Exhibition (DATE)},
  title =        {Introduction to hardware Trojan detection methods},
  year =         {2015},
  volume =       {},
  number =       {},
  pages =        {770-775},
  abstract =     {Hardware Trojans (HTs) are identified as an emerging
                  threat for the integrity of Integrated Circuits (ICs) and
                  their applications. Attackers attempt to maliciously
                  manipulate the functionality of ICs by inserting HTs,
                  potentially causing disastrous effects (Denial of
                  Service, sensitive information leakage, etc.). Over the
                  last 10 years, various methods have been proposed in
                  literature to circumvent HTs. This article introduces the
                  general context of HTs and summarizes the recent advances
                  in HT detection from a French funded research project
                  named HOMERE. Some of these results will be detailed in
                  the related special session.},
  keywords =     {},
  doi =          {10.7873/DATE.2015.1101},
  ISSN =         {1558-1101},
  month =        {March},
}
@INPROCEEDINGS{dupuis-date2015,
  author =       {Dupuis, Sophie and Ba, Papa-Sidy and Flottes, Marie-Lise
                  and Di Natale, Giorgio and Rouzeyre, Bruno},
  booktitle =    {2015 Design, Automation Test in Europe Conference
                  Exhibition (DATE)},
  title =        {New testing procedure for finding insertion sites of
                  stealthy Hardware Trojans},
  year =         {2015},
  volume =       {},
  number =       {},
  pages =        {776-781},
  abstract =     {Hardware Trojans (HTs) are malicious alterations to a
                  circuit. These modifications can be inserted either
                  during the design phase or during the fabrication
                  process. Due to the diversity of Hardware Trojans,
                  detecting and/or locating them are challenging
                  tasks. Numerous approaches have been proposed to address
                  this problem. Methods based on logic testing consist in
                  trying to activate potential HTs and detect erroneous
                  outputs during test. However, HTs are stealthy in nature
                  i.e. mostly inactive unless they are triggered by a very
                  rare condition. The activation of a HT is therefore a
                  major challenge. In this paper, we propose a new testing
                  procedure dedicated to identifying where a possible HT
                  may be easily inserted and generating the test patterns
                  that are able to excite these sites. The selection of the
                  sites is based on the assumption that the HT (i) is
                  triggered by signals with low controllability, (ii)
                  combines them using gates in close proximity in the
                  circuit's layout, and (iii) without introducing new gates
                  in critical paths.},
  keywords =     {},
  doi =          {10.7873/DATE.2015.1102},
  ISSN =         {1558-1101},
  month =        {March},
}
@INPROCEEDINGS{bomberman-trippel-oakland2021,
  author =       {Trippel, Timothy and Shin, Kang G. and Bush, Kevin B. and
                  Hicks, Matthew},
  booktitle =    {2021 IEEE Symposium on Security and Privacy (SP)},
  title =        {Bomberman: Defining and Defeating Hardware Ticking
                  Timebombs at Design-time},
  year =         {2021},
  volume =       {},
  number =       {},
  pages =        {970-986},
  abstract =     {To cope with ever-increasing design complexities,
                  integrated circuit designers increase both the size of
                  their design teams and their reliance on third-party
                  intellectual property (IP). Both come at the expense of
                  trust: it is computationally infeasible to exhaustively
                  verify that a design is free of all possible malicious
                  modifications (i.e., hardware Trojans). Making matters
                  worse, unlike software, hardware modifications are
                  permanent: there is no "patching" mechanism for hardware;
                  and powerful: they serve as a foothold for subverting
                  software that sits above.To counter this threat, prior
                  work uses both static and dynamic analysis techniques to
                  verify hardware designs are Trojan-free. Unfortunately,
                  researchers continue to reveal weaknesses in these
                  "one-size-fits-all", heuristic-based approaches. Instead
                  of attempting to detect all possible hardware Trojans, we
                  take the first step in addressing the hardware Trojan
                  threat in a divide-and-conquer fashion: defining and
                  eliminating Ticking Timebomb Trojans (TTTs), forcing
                  attackers to implement larger Trojan designs detectable
                  via existing verification and side-channel defenses. Like
                  many system-level software defenses (e.g., Address Space
                  Layout Randomization (ASLR) and Data Execution Prevention
                  (DEP)), our goal is to systematically constrict the
                  hardware attacker’s design space.First, we construct a
                  definition of TTTs derived from their functional
                  behavior. Next, we translate this definition into
                  fundamental components required to realize TTT behavior
                  in hardware. Using these components, we expand the set of
                  all known TTTs to a total of six variants—including
                  unseen variants. Leveraging our definition, we design and
                  implement a TTT-specific dynamic verification toolchain
                  extension, called Bomber-man. Using four real-world
                  hardware designs, we demonstrate Bomberman’s ability to
                  detect all TTT variants, where previous defenses fail,
                  with <1.2\% false positives.},
  keywords =     {},
  doi =          {10.1109/SP40001.2021.00052},
  ISSN =         {2375-1207},
  month =        {May},
}
@INPROCEEDINGS{sok-ewim-szekeres-oakland2013,
  author =       {Szekeres, László and Payer, Mathias and Wei, Tao and
                  Song, Dawn},
  booktitle =    {2013 IEEE Symposium on Security and Privacy},
  title =        {SoK: Eternal War in Memory},
  year =         {2013},
  volume =       {},
  number =       {},
  pages =        {48-62},
  doi =          {10.1109/SP.2013.13}
}
@inproceedings{balasubramanian-hotos2017,
  author =       {Balasubramanian, Abhiram and Baranowski, Marek S. and
                  Burtsev, Anton and Panda, Aurojit and Rakamari\'{c},
                  Zvonimir and Ryzhyk, Leonid},
  title =        {System Programming in Rust: Beyond Safety},
  year =         {2017},
  isbn =         {9781450350686},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3102980.3103006},
  doi =          {10.1145/3102980.3103006},
  abstract =     {Rust is a new system programming language that offers a
                  practical and safe alternative to C. Rust is unique in
                  that it enforces safety without runtime overhead, most
                  importantly, without the overhead of garbage
                  collection. While zero-cost safety is remarkable on its
                  own, we argue that the superpowers of Rust go beyond
                  safety. In particular, Rust's linear type system enables
                  capabilities that cannot be implemented efficiently in
                  traditional languages, both safe and unsafe, and that
                  dramatically improve security and reliability of system
                  software. We show three examples of such capabilities:
                  zero-copy software fault isolation, efficient static
                  information flow analysis, and automatic
                  checkpointing. While these capabilities have been in the
                  spotlight of systems research for a long time, their
                  practical use is hindered by high cost and complexity. We
                  argue that with the adoption of Rust these mechanisms
                  will become commoditized.},
  booktitle =    {Proceedings of the 16th Workshop on Hot Topics in
                  Operating Systems},
  pages =        {156–161},
  numpages =     {6},
  location =     {Whistler, BC, Canada},
  series =       {HotOS '17}
}
@techreport{merigoux-inria2021,
  TITLE =        {{Hacspec: succinct, executable, verifiable specifications
                  for high-assurance cryptography embedded in Rust}},
  AUTHOR =       {Merigoux, Denis and Kiefer, Franziskus and Bhargavan,
                  Karthikeyan},
  URL =          {https://hal.inria.fr/hal-03176482},
  TYPE =         {Technical Report},
  INSTITUTION =  {{Inria}},
  YEAR =         {2021},
  MONTH =        Mar,
  PDF =          {https://hal.inria.fr/hal-03176482/file/main.pdf},
  HAL_ID =       {hal-03176482},
  HAL_VERSION =  {v1},
}
@misc{openethereum-github,
  title =        "OpenEthereum Project",
  url =          "https://openethereum.github.io/",
  note =         "https://openethereum.github.io/"
}
@misc{ret2usr:cve,
  Author = {MITRE},
  Title = {{CVE-2009-1897: Linux Kernel Privilege Escalation Vulnerability}},
  Month = {June},
  Year = {2009},
  howpublished = "\url{http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1897}",
  note = "[Online; accessed 11-March-2019]",
}
@misc{cve-2019-17006,
  Author = {MITRE},
  Title = {{CVE-2019-17006: Network Security Services Missing Length Checks}},
  Month = {June},
  Year = {2009},
  howpublished = "\url{https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-17006}",
  note = "[Online; accessed 31-Jan-2022]",
}
@misc{cve-2015-9028,
  Author = {MITRE},
  Title = {{CVE-2015-9028: Linux Kernel Crypto Buffer Overflow}},
  Month = {June},
  Year = {2009},
  howpublished = "\url{https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2015-9028}",
  note = "[Online; accessed 31-Jan-2022]",
}
@misc{cve-2006-0095,
  Author = {MITRE},
  Title = {{CVE-2006-0095: Linux Kernel Crypto Key Disclosure}},
  Month = {June},
  Year = {2009},
  howpublished = "\url{http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1897}",
  note = "[Online; accessed 31-Jan-2022]",
}
@misc{cve-2009-1897,
  Author = {MITRE},
  Title = {{CVE-2009-1897: Linux Kernel NULL Pointer Dereference Privilege
  Escalation}},
  Month = {June},
  Year = {2009},
  howpublished = "\url{https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1897}",
  note = "[Online; accessed 31-Jan-2022]",
}
@INPROCEEDINGS{wordrev-li-host2013,
  author =       {Li, Wenchao and Gascon, Adria and Subramanyan, Pramod and
                  Tan, Wei Yang and Tiwari, Ashish and Malik, Sharad and
                  Shankar, Natarajan and Seshia, Sanjit A.},
  booktitle =    {2013 IEEE International Symposium on Hardware-Oriented
                  Security and Trust (HOST)},
  title =        {WordRev: Finding word-level structures in a sea of
                  bit-level gates},
  year =         {2013},
  volume =       {},
  number =       {},
  pages =        {67-74},
  abstract =     {Systems are increasingly being constructed from
                  off-the-shelf components acquired through a globally
                  distributed and untrusted supply chain. Often only
                  post-synthesis gate-level netlists or actual silicons are
                  available for security inspection. This makes reasoning
                  about hardware trojans particularly challenging given the
                  enormous scale of the problem. Currently, there is no
                  mature methodology that can provide visibility into a
                  bit-level design in terms of high-level components to
                  allow more comprehensive analysis. In this paper, we
                  present a systemic way of automatically deriving
                  word-level structures from the gate-level netlist of a
                  digital circuit. Our framework also provides the
                  possibility for a user to specify sequences of word-level
                  operations and it can extract the collection of gates
                  corresponding to those operations. We demonstrate the
                  effectiveness of our approach on a system-on-a-chip (SoC)
                  design consisting of approximately 400,000 IBM 12SOI
                  cells and several open-source designs.},
  keywords =     {},
  doi =          {10.1109/HST.2013.6581568},
  ISSN =         {},
  month =        {June},
}
@inproceedings{detrust-zhang-ccs2014,
  author =       {Zhang, Jie and Yuan, Feng and Xu, Qiang},
  title =        {DeTrust: Defeating Hardware Trust Verification with
                  Stealthy Implicitly-Triggered Hardware Trojans},
  year =         {2014},
  isbn =         {9781450329576},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/2660267.2660289},
  doi =          {10.1145/2660267.2660289},
  abstract =     {Hardware Trojans (HTs) inserted at design time by
                  malicious insiders on the design team or third-party
                  intellectual property (IP) providers pose a serious
                  threat to the security of computing systems. Researchers
                  have proposed several hardware trust verification
                  techniques to mitigate such threats, and some of them are
                  shown to be able to effectively flag all suspicious HTs
                  implemented in the Trust-Hub hardware backdoor benchmark
                  suite. No doubt to say, adversaries would adjust their
                  tactics of attacks accordingly and it is hence essential
                  to examine whether new types of HTs can be designed to
                  defeat these hardware trust verification techniques. In
                  this paper, we present a systematic HT design methodology
                  to achieve the above objective, namely
                  emph{DeTrust}. Given an HT design, DeTrust keeps its
                  original malicious behavior while making the HT resistant
                  to state-of-the-art hardware trust verification
                  techniques by manipulating its trigger designs. To be
                  specific, DeTrust implements stealthy implicit triggers
                  for HTs by carefully spreading the trigger logic into
                  multiple sequential levels and combinational logic blocks
                  and combining the trigger logic with the normal logic, so
                  that they are not easily differentiable from normal
                  logic. As shown in our experimental results, adversaries
                  can easily employ DeTrust to evade hardware trust
                  verification.We close with a discussion on how to extend
                  existing solutions to alleviate the threat posed by
                  DeTrust. However, they generally suffer from high
                  computational complexity, calling for more advanced
                  techniques to ensure hardware trust.},
  booktitle =    {Proceedings of the 2014 ACM SIGSAC Conference on Computer
                  and Communications Security},
  pages =        {153–166},
  numpages =     {14},
  keywords =     {implicit trigger, hardware security, backdoors, hardware
                  trojan},
  location =     {Scottsdale, Arizona, USA},
  series =       {CCS '14}
}
@misc{indexing-rustlang,
  Title =        {{The Rust Reference: Array and Index Expressions}},
  howpublished =
                  "\url{https://doc.rust-lang.org/reference/expressions/array-expr.html#array-and-slice-indexing-expressions}",
  note =         "[Online; accessed 30-Dec-2021]",
}

@inproceedings {cain-barresi-woot2015,
author = {Antonio Barresi and Kaveh Razavi and Mathias Payer and Thomas R. Gross},
title = {{CAIN}: Silently Breaking {ASLR} in the Cloud},
booktitle = {9th USENIX Workshop on Offensive Technologies (WOOT 15)},
year = {2015},
address = {Washington, D.C.},
url = {https://www.usenix.org/conference/woot15/workshop-program/presentation/barresi},
publisher = {USENIX Association},
month = aug,
}

@misc{exploit-mitigation-rustlang,
  Title =        {{The rustc book: Exploit Mitigations}},
  howpublished =
                  "\url{https://doc.rust-lang.org/beta/rustc/exploit-mitigations.html}",
  note =         "[Online; accessed 30-Dec-2021]",
}
@INPROCEEDINGS{qifverilog-guo-host2019,
  author =       {Guo, Xiaolong and Dutta, Raj Gautam and He, Jiaji and
                  Tehranipoor, Mark M. and Jin, Yier},
  booktitle =    {2019 IEEE International Symposium on Hardware Oriented
                  Security and Trust (HOST)},
  title =        {QIF-Verilog: Quantitative Information-Flow based Hardware
                  Description Languages for Pre-Silicon Security
                  Assessment},
  year =         {2019},
  volume =       {},
  number =       {},
  pages =        {91-100},
  abstract =     {Hardware vulnerabilities are often due to design mistakes
                  because the designer does not sufficiently consider
                  potential security vulnerabilities at the design
                  stage. As a result, various security solutions have been
                  developed to protect ICs, among which the language-based
                  hardware security verification serves as a promising
                  solution. The verification process will be performed
                  while compiling the HDL of the design. However, similar
                  to other formal verification methods, the language-based
                  approach also suffers from scalability
                  issue. Furthermore, existing solutions either lead to
                  hardware overhead or are not designed for vulnerable or
                  malicious logic detection. To alleviate these challenges,
                  we propose a new language based framework, QIF-Verilog,
                  to evaluate the trustworthiness of a hardware system at
                  register transfer level (RTL). This framework introduces
                  a quantified information flow (QIF) model and extends
                  Verilog type systems to provide more expressiveness in
                  presenting security rules; QIF is capable of checking the
                  security rules given by the hardware designer. Secrets
                  are labeled by the new type and then parsed to data flow,
                  to which a QIF model will be applied. To demonstrate our
                  approach, we design a compiler for QIF-Verilog and
                  perform vulnerability analysis on benchmarks from
                  Trust-Hub and OpenCore. We show that Trojans or design
                  faults that leak information from circuit outputs can be
                  detected automatically, and that our method evaluates the
                  security of the design correctly.},
  keywords =     {},
  doi =          {10.1109/HST.2019.8740840},
  ISSN =         {},
  month =        {May},
}

@INPROCEEDINGS{defeatinguci-sturton-oakland2011,
  author =       {Sturton, Cynthia and Hicks, Matthew and Wagner, David and
                  King, Samuel T.},
  booktitle =    {2011 IEEE Symposium on Security and Privacy},
  title =        {Defeating UCI: Building Stealthy and Malicious Hardware},
  year =         {2011},
  volume =       {},
  number =       {},
  pages =        {64-77},
  abstract =     {In previous work Hicks et al. proposed a method called
                  Unused Circuit Identification (UCI) for detecting
                  malicious backdoors hidden in circuits at design
                  time. The UCI algorithm essentially looks for portions of
                  the circuit that go unused during design-time testing and
                  flags them as potentially malicious. In this paper we
                  construct circuits that have malicious behavior, but that
                  would evade detection by the UCI algorithm and still pass
                  design-time test cases. To enable our search for such
                  circuits, we define one class of malicious circuits and
                  perform a bounded exhaustive enumeration of all circuits
                  in that class. Our approach is simple and straight
                  forward, yet it proves to be effective at finding
                  circuits that can thwart UCI. We use the results of our
                  search to construct a practical attack on an open-source
                  processor. Our malicious backdoor allows any user-level
                  program running on the processor to enter supervisor mode
                  through the use of a secret â knock. We close with a
                  discussion on what we see as a major challenge facing any
                  future design-time malicious hardware detection scheme:
                  identifying a sufficient class of malicious circuits to
                  defend against.},
  keywords =     {},
  doi =          {10.1109/SP.2011.32},
  ISSN =         {2375-1207},
  month =        {May},
}

@article{gem5,
  author =       {Binkert, Nathan and Beckmann, Bradford and Black, Gabriel
                  and Reinhardt, Steven K. and Saidi, Ali and Basu,
                  Arkaprava and Hestness, Joel and Hower, Derek R. and
                  Krishna, Tushar and Sardashti, Somayeh and Sen, Rathijit
                  and Sewell, Korey and Shoaib, Muhammad and Vaish, Nilay
                  and Hill, Mark D. and Wood, David A.},
  title =        {The Gem5 Simulator},
  year =         {2011},
  issue_date =   {May 2011},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {39},
  number =       {2},
  issn =         {0163-5964},
  url =          {https://doi.org/10.1145/2024716.2024718},
  doi =          {10.1145/2024716.2024718},
  abstract =     {The gem5 simulation infrastructure is the merger of the
                  best aspects of the M5 [4] and GEMS [9] simulators. M5
                  provides a highly configurable simulation framework,
                  multiple ISAs, and diverse CPU models. GEMS complements
                  these features with a detailed and exible memory system,
                  including support for multiple cache coherence protocols
                  and interconnect models. Currently, gem5 supports most
                  commercial ISAs (ARM, ALPHA, MIPS, Power, SPARC, and
                  x86), including booting Linux on three of them (ARM,
                  ALPHA, and x86).The project is the result of the combined
                  efforts of many academic and industrial institutions,
                  including AMD, ARM, HP, MIPS, Princeton, MIT, and the
                  Universities of Michigan, Texas, and Wisconsin. Over the
                  past ten years, M5 and GEMS have been used in hundreds of
                  publications and have been downloaded tens of thousands
                  of times. The high level of collaboration on the gem5
                  project, combined with the previous success of the
                  component parts and a liberal BSD-like license, make gem5
                  a valuable full-system simulation tool.},
  journal =      {SIGARCH Comput. Archit. News},
  month =        {aug},
  pages =        {1–7},
  numpages =     {7}
}
@misc{gem5-o3cpu,
  Title =        {{gem5: O3CPU}},
  howpublished =
                  "\url{https://www.gem5.org/documentation/general_docs/cpu_models/O3CPU}",
  note =         "[Online; accessed 17-Feb-2022]",
}
@article{AlephOne:StackSmash,
  author =       {Aleph One},
  title =        {{Smashing the Stack for Fun and Profit}},
  volume =       7,
  issue =        49,
  month =        {November},
  day =          8,
  year =         1996,
  journal =      "Phrack",
  note =         "\url{http://www.phrack.org/issues/49/14.html} [Online;
                  accessed 11-March-2019]",
}
@inproceedings{Ret2Libc:RAID11,
  author =       {Tran, Minh and Etheridge, Mark and Bletsch, Tyler and
                  Jiang, Xuxian and Freeh, Vincent and Ning, Peng},
  title =        {{On the Expressiveness of Return-into-libc Attacks}},
  booktitle =    {Proceedings of the 14th International Conference on
                  Recent Advances in Intrusion Detection (RAID)},
  year =         {2011},
  isbn =         {978-3-642-23643-3},
  address =      {Menlo Park, CA},
  pages =        {121--141},
  numpages =     {21},
  doi =          {10.1007/978-3-642-23644-0_7},
  acmid =        {2186337},
  keywords =     {return-into-libc, return-oriented programming,
                  turingcomplete},
}
@article{ROP:TOISS12,
  author =       {Roemer, Ryan and Buchanan, Erik and Shacham, Hovav and
                  Savage, Stefan},
  title =        {{Return-Oriented Programming: Systems, Languages, and
                  Applications}},
  journal =      {ACM Transactions on Information Systems Security
                  (TISSEC)},
  issue_date =   {March 2012},
  volume =       {15},
  number =       {1},
  month =        mar,
  year =         {2012},
  issn =         {1094-9224},
  pages =        {2:1--2:34},
  articleno =    {2},
  numpages =     {34},
  acmid =        {2133377},
  publisher =    {ACM},
  address =      {New York, NY, USA},
  keywords =     {NX, RISC, Return-oriented programming, SPARC, W-xor-X,
                  attacks, control flow integrity, memory safety,
                  return-into-libc, x86},
}
@inproceedings{ruwase-ndss2004,
  author =       {O. Ruwase and M. Lam},
  title =        {{A Practical Dynamic Buffer Overflow Detector}},
  booktitle =    {{In Proceedings of the Network and Distributed System
                  Security (NDSS) Symposium}},
  pages =        {159--169},
  month =        February,
  year =         2004,
  address =      {San Diego, CA, USA},
  url =          {citeseer.ist.psu.edu/ruwase04practical.html}
}
@misc{rust-safe-systems-thenewstack2020,
  Author =       {Joab Jackson},
  Title =        {{Microsoft: Rust Is the Industry’s ‘Best Chance’ at Safe
                  Systems Programming}},
  Month =        {June},
  Year =         {2020},
  howpublished =
                  "\url{https://thenewstack.io/microsoft-rust-is-the-industrys-best-chance-at-safe-systems-programming/}",
  note =         "[Online; accessed 22-Feb-2022]",
}
@misc{safer-systems-programming-msrc2019,
  Author =       {Ryan Levick and Sebastian Fernandez},
  Title =        {{We need a safer systems programming language}},
  Month =        {July},
  Year =         {2019},
  howpublished =
                  "\url{https://msrc-blog.microsoft.com/2019/07/18/we-need-a-safer-systems-programming-language/}",
  note =         "[Online; accessed 22-Feb-2022]",
}
@inproceedings{pl-efficiency-pereira-sle2017,
  author =       {Pereira, Rui and Couto, Marco and Ribeiro, Francisco and
                  Rua, Rui and Cunha, J\'{a}come and Fernandes, Jo\~{a}o
                  Paulo and Saraiva, Jo\~{a}o},
  title =        {Energy Efficiency across Programming Languages: How Do
                  Energy, Time, and Memory Relate?},
  year =         {2017},
  isbn =         {9781450355254},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/3136014.3136031},
  doi =          {10.1145/3136014.3136031},
  abstract =     { This paper presents a study of the runtime, memory usage
                  and energy consumption of twenty seven well-known
                  software languages. We monitor the performance of such
                  languages using ten different programming problems,
                  expressed in each of the languages. Our results show
                  interesting findings, such as, slower/faster languages
                  consuming less/more energy, and how memory usage
                  influences energy consumption. Finally, we show how to
                  use our results to provide software engineers support to
                  decide which language to use when energy efficiency is a
                  concern. },
  booktitle =    {Proceedings of the 10th ACM SIGPLAN International
                  Conference on Software Language Engineering},
  pages =        {256–267},
  numpages =     {12},
  keywords =     {Programming Languages, Language Benchmarking, Energy
                  Efficiency, Green Software},
  location =     {Vancouver, BC, Canada},
  series =       {SLE 2017}
}
@book{rust,
  author =       {Klabnik, Steve and Nichols, Carol},
  title =        {The Rust Programming Language},
  year =         {2018},
  isbn =         {1593278284},
  publisher =    {No Starch Press},
  address =      {USA},
  abstract =     {The Rust Programming Language is the official book on
                  Rust, an open-source, community-developed systems
                  programming language that runs blazingly fast, prevents
                  segfaults, and guarantees thread safety. This is the
                  undisputed go-to guide to Rust, written by two members of
                  the Rust core team, with feedback and contributions from
                  42 members of the community. The book assumes that youve
                  written code in another programming language but makes no
                  assumptions about which one, meaning the material is
                  accessible and useful to developers from a wide variety
                  of programming backgrounds. Known by the Rust community
                  as The Book, The Rust Programming Language includes
                  concept chapters, where youll learn about a particular
                  aspect of Rust, and project chapters, where youll apply
                  what youve learned so far to build small programs. The
                  Book opens with a quick hands-on project to introduce the
                  basics then explores key concepts in depth, such as
                  ownership, the type system, error handling, and fearless
                  concurrency. Next come detailed explanations of
                  Rust-oriented perspectives on topics like pattern
                  matching, iterators, and smart pointers, with concrete
                  examples and exercises--taking you from theory to
                  practice. The Rust Programming Language will also show
                  you how to:- Grasp important concepts unique to Rust,
                  like ownership, borrowing, and lifetimes- Use Cargo,
                  Rusts built-in package manager, to build and maintain
                  your code, including downloading and building
                  dependencies- Effectively use Rusts zero-cost
                  abstractions and employ your own Youll learn to develop
                  reliable code thats speed and memory efficient, while
                  avoiding the infamous and arcane programming pitfalls
                  common at the systems level. When you need to dive down
                  into lower-level control, this guide will show you how
                  without taking on the customary risk of crashes or
                  security holes and without requiring you to learn the
                  fine points of a fickle toolchain. Youll also learn how
                  to create command line programs, build single- and
                  multithreaded web servers, and much more. The Rust
                  Programming Language fully embraces Rusts potential to
                  empower its users. This friendly and approachable guide
                  will help you build not only your knowledge of Rust but
                  also your ability to program with confidence in a wider
                  variety of domains.}
}
@misc{kotlin,
  Author =       {Marat Akhin and Mikhail Belyaev et al.},
  Title =        {{Kotlin language specification: Kotlin/Core}},
  Year =         {2020},
  howpublished = "JetBrains / JetBrains Research
                  \url{https://kotlinlang.org/spec}",
  note =         "[Online; accessed 23-Feb-2022]",
}

@misc{golang,
  Title =        {{The Go Programming Language Specification}},
  Day =          {26},
  Month =        {July},
  Year =         {2021},
  howpublished = "\url{https://go.dev/ref/spec}",
  note =         "[Online; accessed 23-Feb-2022]",
}
@misc{csharp,
  Title =        {{C\# language specification}},
  Day =          {22},
  Month =        {February},
  Year =         {2022},
  howpublished = "Microsoft Docs
                  \url{https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification}",
  note =         "[Online; accessed 23-Feb-2022]",
}

@misc{rust-security,
  Title =        {{The rustc book: Exploit Mitigations}},
  howpublished = "\url{https://doc.rust-lang.org/beta/rustc/exploit-mitigations.html}",
  note =         "[Online; accessed 23-Feb-2022]",
}

@INPROCEEDINGS{layout-filling-ba-isvlsi2016,
  author =       {Ba, Papa-Sidy and Dupuis, Sophie and Palanichamy,
                  Manikandan and Flottes, Marie-Lise and Di Natale, Giorgio
                  and Rouzeyre, Bruno},
  booktitle =    {2016 IEEE Computer Society Annual Symposium on VLSI
                  (ISVLSI)},
  title =        {Hardware Trust through Layout Filling: A Hardware Trojan
                  Prevention Technique},
  year =         {2016},
  volume =       {},
  number =       {},
  pages =        {254-259},
  abstract =     {The insertion of malicious alterations to a circuit,
                  referred to as Hardware Trojans, is a threat considered
                  more and more seriously during the last years. Numerous
                  methods have been proposed in the literature to detect
                  the presence of such alterations. More recently,
                  Design-for-Hardware-Trust (DfHT) methods have been
                  proposed, that enhance the design of the circuit in order
                  to incorporate features that can either prevent the
                  insertion of a HT or that can help detection
                  methods. This paper focuses on a HT prevention technique
                  that aims at creating a layout without filler cells,
                  which are assumed to provide a great opportunity for HT
                  insertion, in order to make the insertion of a HT in a
                  layout as difficult as possible.},
  keywords =     {},
  doi =          {10.1109/ISVLSI.2016.22},
  ISSN =         {2159-3477},
  month =        {July},
}
@inproceedings{muehlberghuber-hasp2013,
  author =       {Muehlberghuber, Michael and G\"{u}rkaynak, Frank K. and
                  Korak, Thomas and Dunst, Philipp and Hutter, Michael},
  title =        {Red Team vs. Blue Team Hardware Trojan Analysis:
                  Detection of a Hardware Trojan on an Actual ASIC},
  year =         {2013},
  isbn =         {9781450321181},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/2487726.2487727},
  doi =          {10.1145/2487726.2487727},
  abstract =     {We infiltrate the ASIC development chain by inserting a
                  small denial-of-service (DoS) hardware Trojan at the
                  fabrication design phase into an existing VLSI circuit,
                  thereby simulating an adversary at a semiconductor
                  foundry. Both the genuine and the altered ASICs have been
                  fabricated using a 180 nm CMOS process. The Trojan
                  circuit adds an overhead of only 0.5% to the original
                  design. In order to detect the hardware Trojan, we
                  perform side-channel analyses and apply IC-fingerprinting
                  techniques using templates, principal component analysis
                  (PCA), and support vector machines (SVMs). As a result,
                  we were able to successfully identify and classify all
                  infected ASICs from non-infected ones. To the best of our
                  knowledge, this is the first hardware Trojan manufactured
                  as an ASIC and has successfully been analyzed using side
                  channels.},
  booktitle =    {Proceedings of the 2nd International Workshop on Hardware
                  and Architectural Support for Security and Privacy},
  articleno =    {1},
  numpages =     {8},
  keywords =     {hardware trojan, side-channel analysis, PCA, ASIC
                  fabrication, SVM},
  location =     {Tel-Aviv, Israel},
  series =       {HASP '13}
}
@inproceedings{sok-tee-zhang-hasp2016,
  author =       {Zhang, Fengwei and Zhang, Hongwei},
  title =        {SoK: A Study of Using Hardware-Assisted Isolated
                  Execution Environments for Security},
  year =         {2016},
  isbn =         {9781450347693},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/2948618.2948621},
  doi =          {10.1145/2948618.2948621},
  abstract =     {Hardware-assisted Isolated Execution Environments (HIEEs)
                  have been widely adopted to build effective and efficient
                  defensive tools for securing systems. Hardware vendors
                  have introduced a variety of HIEEs including system
                  management mode, Intel management engine, ARM TrustZone,
                  and Intel software guard extensions. This SoK paper
                  presents a comprehensive study of existing HIEEs and
                  compares their features from the security
                  perspective. Additionally, we explore both defensive and
                  offensive use scenarios of HIEEs and discuss the attacks
                  against HIEE-based systems. Overall, this paper aims to
                  give an essential checkpoint of the state-of-the-art
                  systems that use HIEEs for trustworthy computing.},
  booktitle =    {Proceedings of the Hardware and Architectural Support for
                  Security and Privacy 2016},
  articleno =    {3},
  numpages =     {8},
  keywords =     {hardware, Isolated execution environments, security},
  location =     {Seoul, Republic of Korea},
  series =       {HASP 2016}
}
@INPROCEEDINGS{perez-iscas2021,
  author =       {Perez, Tiago and Imran, Malik and Vaz, Pablo and
                  Pagliarini, Samuel},
  booktitle =    {2021 IEEE International Symposium on Circuits and Systems
                  (ISCAS)},
  title =        {Side-Channel Trojan Insertion - a Practical Foundry-Side
                  Attack via ECO},
  year =         {2021},
  volume =       {},
  number =       {},
  pages =        {1-5},
  abstract =     {Design companies often outsource their integrated circuit
                  (IC) fabrication to third parties where ICs are
                  susceptible to malicious acts such as the insertion of a
                  side-channel hardware trojan horse (SCT). In this paper,
                  we present a framework for designing and inserting an SCT
                  based on an engineering change order (ECO) flow, which
                  makes it the first to disclose how effortlessly a trojan
                  can be inserted into an IC. The trojan is designed with
                  the goal of leaking multiple bits per power signature
                  reading. Our findings and results show that a rogue
                  element within a foundry has, today, all means necessary
                  for performing a foundry-side attack via ECO.},
  keywords =     {},
  doi =          {10.1109/ISCAS51556.2021.9401481},
  ISSN =         {2158-1525},
  month =        {May},
}
@INPROCEEDINGS{img-courbon-date2015,
  author =       {Courbon, Franck and Loubet-Moundi, Philippe and Fournier,
                  Jacques J.A. and Tria, Assia},
  booktitle =    {2015 Design, Automation Test in Europe Conference
                  Exhibition (DATE)},
  title =        {A high efficiency Hardware Trojan detection technique
                  based on fast SEM imaging},
  year =         {2015},
  volume =       {},
  number =       {},
  pages =        {788-793},
  abstract =     {In the semiconductor market where more and more companies
                  become fabless, malicious integrated circuits'
                  modifications are seen as possible threats. Those
                  Hardware Trojans can have various effects and can be
                  implemented by different entities with different
                  means. This article includes the integration of an almost
                  automatic Hardware Trojan detection. The latter is based
                  on a visual inspection implemented within the integrated
                  circuit life cycle. The proposed detection methodology is
                  quite efficient regarding tools, user experience and time
                  needed. A single layer of the chip is accessed and then
                  imaged with a Scanning Electron Microscope (SEM). The
                  acquisition of several hundred images at high
                  magnification is automated as does the images
                  registration. Then depending on the reference
                  availability, one can check if any supplementary gates
                  have been inserted in the design using a golden reference
                  or a graphic/text design file. Depending on the
                  reference, either basic image processing is used to
                  compare the chip extracted image with a golden model or
                  some pattern recognition can be used to retrieve the
                  number of occurrences of each standard cell. The depicted
                  methodology aims to detect any gate modification,
                  substitution, removal or addition and so far require an
                  invasive approach and a reference.},
  keywords =     {},
  doi =          {10.7873/DATE.2015.1104},
  ISSN =         {1558-1101},
  month =        {March},
}
@inproceedings{ret2libc-tran-raid2011,
  author =       {Tran, Minh and Etheridge, Mark and Bletsch, Tyler and
                  Jiang, Xuxian and Freeh, Vincent and Ning, Peng},
  title =        {{On the Expressiveness of Return-into-libc Attacks}},
  booktitle =    {Proceedings of the 14th International Conference on
                  Recent Advances in Intrusion Detection (RAID)},
  year =         {2011},
  isbn =         {978-3-642-23643-3},
  address =      {Menlo Park, CA},
  pages =        {121--141},
  numpages =     {21},
  doi =          {10.1007/978-3-642-23644-0_7},
  acmid =        {2186337},
  keywords =     {return-into-libc, return-oriented programming,
                  turingcomplete},
}
@article{ret2libc-wojtczuk-phrack2001,
  title =        {The advanced return-into-lib (c) exploits: Pax case
                  study},
  author =       {Wojtczuk, Rafal},
  journal =      {Phrack Magazine, Volume 0x0b, Issue 0x3a, Phile\# 0x04 of
                  0x0e},
  volume =       {70},
  year =         {2001}
}
@article{rop-roemer-tiss2012,
  author =       {Roemer, Ryan and Buchanan, Erik and Shacham, Hovav and
                  Savage, Stefan},
  title =        {Return-Oriented Programming: Systems, Languages, and
                  Applications},
  year =         {2012},
  issue_date =   {March 2012},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  volume =       {15},
  number =       {1},
  issn =         {1094-9224},
  url =          {https://doi.org/10.1145/2133375.2133377},
  doi =          {10.1145/2133375.2133377},
  abstract =     {We introduce return-oriented programming, a technique by
                  which an attacker can induce arbitrary behavior in a
                  program whose control flow he has diverted, without
                  injecting any code. A return-oriented program chains
                  together short instruction sequences already present in a
                  program’s address space, each of which ends in a “return”
                  instruction.Return-oriented programming defeats the W⊕X
                  protections recently deployed by Microsoft, Intel, and
                  AMD; in this context, it can be seen as a generalization
                  of traditional return-into-libc attacks. But the threat
                  is more general. Return-oriented programming is readily
                  exploitable on multiple architectures and systems. It
                  also bypasses an entire category of security
                  measures---those that seek to prevent malicious
                  computation by preventing the execution of malicious
                  code.To demonstrate the wide applicability of
                  return-oriented programming, we construct a
                  Turing-complete set of building blocks called gadgets
                  using the standard C libraries of two very different
                  architectures: Linux/x86 and Solaris/SPARC. To
                  demonstrate the power of return-oriented programming, we
                  present a high-level, general-purpose language for
                  describing return-oriented exploits and a compiler that
                  translates it to gadgets.},
  journal =      {ACM Trans. Inf. Syst. Secur.},
  month =        {mar},
  articleno =    {2},
  numpages =     {34},
  keywords =     {control flow integrity, NX, return-into-libc, attacks,
                  Return-oriented programming, W-xor-X, memory safety,
                  RISC, x86, SPARC}
}
@inproceedings{jop-bletsch-asiaccs2011,
  author =       {Bletsch, Tyler and Jiang, Xuxian and Freeh, Vince W. and
                  Liang, Zhenkai},
  title =        {Jump-Oriented Programming: A New Class of Code-Reuse
                  Attack},
  year =         {2011},
  isbn =         {9781450305648},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/1966913.1966919},
  doi =          {10.1145/1966913.1966919},
  abstract =     {Return-oriented programming is an effective code-reuse
                  attack in which short code sequences ending in a ret
                  instruction are found within existing binaries and
                  executed in arbitrary order by taking control of the
                  stack. This allows for Turing-complete behavior in the
                  target program without the need for injecting attack
                  code, thus significantly negating current code injection
                  defense efforts (e.g., W⊕X). On the other hand, its
                  inherent characteristics, such as the reliance on the
                  stack and the consecutive execution of return-oriented
                  gadgets, have prompted a variety of defenses to detect or
                  prevent it from happening.In this paper, we introduce a
                  new class of code-reuse attack, called jump-oriented
                  programming. This new attack eliminates the reliance on
                  the stack and ret instructions (including ret-like
                  instructions such as pop+jmp) seen in return-oriented
                  programming without sacrificing expressive power. This
                  attack still builds and chains functional gadgets, each
                  performing certain primitive operations, except these
                  gadgets end in an indirect branch rather than
                  ret. Without the convenience of using ret to unify them,
                  the attack relies on a dispatcher gadget to dispatch and
                  execute the functional gadgets. We have successfully
                  identified the availability of these jump-oriented
                  gadgets in the GNU libc library. Our experience with an
                  example shellcode attack demonstrates the practicality
                  and effectiveness of this technique.},
  booktitle =    {Proceedings of the 6th ACM Symposium on Information,
                  Computer and Communications Security},
  pages =        {30–40},
  numpages =     {11},
  location =     {Hong Kong, China},
  series =       {ASIACCS '11}
}
@inproceedings{checkoway-ccs2010,
  author =       {Checkoway, Stephen and Davi, Lucas and Dmitrienko,
                  Alexandra and Sadeghi, Ahmad-Reza and Shacham, Hovav and
                  Winandy, Marcel},
  title =        {Return-Oriented Programming without Returns},
  year =         {2010},
  isbn =         {9781450302456},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/1866307.1866370},
  doi =          {10.1145/1866307.1866370},
  abstract =     {We show that on both the x86 and ARM architectures it is
                  possible to mount return-oriented programming attacks
                  without using return instructions. Our attacks instead
                  make use of certain instruction sequences that behave
                  like a return, which occur with sufficient frequency in
                  large libraries on (x86) Linux and (ARM) Android to allow
                  creation of Turing-complete gadget sets.Because they do
                  not make use of return instructions, our new attacks have
                  negative implications for several recently proposed
                  classes of defense against return-oriented programming:
                  those that detect the too-frequent use of returns in the
                  instruction stream; those that detect violations of the
                  last-in, first-out invariant normally maintained for the
                  return-address stack; and those that modify compilers to
                  produce code that avoids the return instruction.},
  booktitle =    {Proceedings of the 17th ACM Conference on Computer and
                  Communications Security},
  pages =        {559–572},
  numpages =     {14},
  keywords =     {arm, x86, return-oriented programming},
  location =     {Chicago, Illinois, USA},
  series =       {CCS '10}
}
@inproceedings{shacham-ccs2007,
  author =       {Shacham, Hovav},
  title =        {The Geometry of Innocent Flesh on the Bone:
                  Return-into-Libc without Function Calls (on the X86)},
  year =         {2007},
  isbn =         {9781595937032},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/1315245.1315313},
  doi =          {10.1145/1315245.1315313},
  abstract =     {We present new techniques that allow a return-into-libc
                  attack to be mounted on x86 executables that calls no
                  functions at all. Our attack combines a large number of
                  short instruction sequences to build gadgets that allow
                  arbitrary computation. We show how to discover such
                  instruction sequences by means of static analysis. We
                  make use, in an essential way, of the properties of the
                  x86 instruction set.},
  booktitle =    {Proceedings of the 14th ACM Conference on Computer and
                  Communications Security},
  pages =        {552–561},
  numpages =     {10},
  keywords =     {return-into-libc, instruction set, turing completeness},
  location =     {Alexandria, Virginia, USA},
  series =       {CCS '07}
}
@inproceedings{strackx-eurosec2009,
  author =       {Strackx, Raoul and Younan, Yves and Philippaerts, Pieter
                  and Piessens, Frank and Lachmund, Sven and Walter,
                  Thomas},
  title =        {Breaking the Memory Secrecy Assumption},
  year =         {2009},
  isbn =         {9781605584720},
  publisher =    {Association for Computing Machinery},
  address =      {New York, NY, USA},
  url =          {https://doi.org/10.1145/1519144.1519145},
  doi =          {10.1145/1519144.1519145},
  abstract =     {Many countermeasures exist that attempt to protect
                  against buffer overflow attacks on applications written
                  in C and C++. The most widely deployed countermeasures
                  rely on artificially introducing randomness in the memory
                  image of the application. StackGuard and similar systems,
                  for instance, will insert a random value before the
                  return address on the stack, and Address Space Layout
                  Randomization (ASLR) will make the location of stack
                  and/or heap less predictable for an attacker.A critical
                  assumption in these probabilistic countermeasures is that
                  attackers cannot read the contents of memory. In this
                  paper we show that this assumption is not always
                  justified. We identify a new class of vulnerabilities --
                  buffer overreads -- that occur in practice and that can
                  be exploited to read parts of the memory contents of a
                  process running a vulnerable application. We describe in
                  detail how to exploit an application protected by both
                  ASLR and stack canaries, if the application contains both
                  a buffer overread and a buffer overflow vulnerability.We
                  also provide a detailed discussion of how this
                  vulnerability affects other, less widely deployed
                  probabilistic countermeasures such as memory obfuscation
                  and instruction set randomization.},
  booktitle =    {Proceedings of the Second European Workshop on System
                  Security},
  pages =        {1–8},
  numpages =     {8},
  keywords =     {systems security, buffer overflow, probabilistic
                  countermeasure, buffer overread, bypass},
  location =     {Nuremburg, Germany},
  series =       {EUROSEC '09}
}
@misc{cve-2009-1897,
  Author =       {MITRE},
  Title =        {{CVE-2012-0769: Adobe Flash Player information leak}},
  Day =          {18},
  Month =        {January},
  Year =         {2012},
  howpublished =
                  "\url{https://cve.mitre.org/cgi-bin/cvename.cgi?name=Cve-2012-0769}",
  note =         "[Online; accessed 28-Feb-2022]",
}
@misc{aslr-pax,
  author =       {The {PaX} Team},
  title =        {{ASLR}},
  howpublished = "\url{http://pax.grsecurity.net/docs/aslr.txt}",
  note =         "[Online; accessed 11-March-2019]",
}
@misc{angrop,
  Title = {{angrop}},
  howpublished = "\url{https://github.com/angr/angrop}",
  note = "[Online; accessed 02-March-2022]",
}
@online{ROPgadget,
  author = {Salwan, Jonathan and Wirth, Allan},
  title = {ROPgadget: Gadgets finder and auto-roper},
  year = {2011},
  url = {http://shell-storm.org/project/ROPgadget},
  note = {\url{http://shell-storm.org/project/ROPgadget}},
}
@misc{gdb,
  Title = {{GDB: The GNU Project Debugger}},
  howpublished = "\url{https://www.sourceware.org/gdb/}",
  note = "[Online; accessed 02-March-2022]",
}
